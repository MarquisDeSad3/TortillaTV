<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <!-- Bloqueo de zoom/pinch en móvil -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
  <title>TortillaTV</title>
  <meta name="theme-color" content="#0b1324" />

  <!-- Fuentes y Tailwind -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@800&family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
 <script src="https://cdn.jsdelivr.net/npm/webgazer/dist/webgazer.min.js"></script>

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ["Inter","system-ui","Segoe UI","Roboto"], display: ["Caveat","ui-serif"] },
          colors: { paper: "#faf9f6", rule: "#93c5fd66", marginRed: "#ef4444aa" },
          keyframes: {
            pageFlipIn: { "0%": { transform:"rotateY(-90deg) translateX(-20px)", opacity:0 }, "100%": { transform:"rotateY(0) translateX(0)", opacity:1 } },
            noteSlide: { "0%":{ transform:"translateX(0%)" }, "100%":{ transform:"translateX(-100%)" } },
            inkSweep: { "0%":{ transform:"translateX(-120%) skewX(-8deg)" , opacity:.0}, "60%":{opacity:.45}, "100%":{ transform:"translateX(120%) skewX(-8deg)", opacity:0 } },
            scribbleFlow: { "0%":{ strokeDashoffset:0 }, "100%":{ strokeDashoffset:-1400 } },
            wobbleIn: { "0%":{ transform:"translateY(12px) scale(.98)", opacity:0 }, "100%":{ transform:"translateY(0) scale(1)", opacity:1 } }
          },
          animation: {
            pageFlipIn: "pageFlipIn .6s ease both",
            noteSlide: "noteSlide .7s cubic-bezier(.22,.61,.36,1) both",
            inkSweep: "inkSweep 1.4s ease-out .15s 1",
            scribbleFlow: "scribbleFlow 5s linear 2s infinite",
            wobbleIn: "wobbleIn .65s ease-out .25s both"
          },
          boxShadow: { card: "0 12px 30px rgba(0,0,0,.07)" }
        }
      }
    }
  </script>

  <!-- Firebase (compat) SOLO login Google -->
  <script src="https://www.gstatic.com/firebasejs/9.6.11/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.11/firebase-auth-compat.js"></script>

  <style>
    :root{
      --paper:#faf9f6; --rule:#93c5fd66; --margin:#ef4444aa; --hole:#e5e7eb; --ink:#111827;
      --box-ar: 1/1; /* PC por defecto 1:1 (captura/ventana) */
      --vh: 1vh; --dvh: 1dvh; /* viewport fix cross-browser */
    }
    body.ar-1-1{ --box-ar: 1/1; }
    body.ar-4-3{ --box-ar: 4/3; }
    body.ar-16-9{ --box-ar: 16/9; }

    html,body{ height:100%; background:var(--paper); color:var(--ink); -webkit-font-smoothing:antialiased; -webkit-text-size-adjust:100%; }

    /* ( ajuste para alinear el scroller) */
    #noteScroller { display:flex; justify-content:flex-start; gap:0.2ch; align-items:center; }
    #noteScroller .slide { font-size: 0.75em; }

    /* Bloquear scroll global cuando estemos en la sala en móvil */
    body.no-scroll{ position:fixed; inset:0; overflow:hidden; width:100%; height:calc(var(--dvh) * 100); }

    /* Evitar gestos extra de zoom en móvil */
    * { touch-action: manipulation; }

    /* Papel y adornos (estética) */
    .paper-bg{ position:relative; min-height:calc(var(--dvh) * 100); background-image:repeating-linear-gradient(0deg, transparent, transparent 32px, var(--rule) 33px, var(--rule) 34px); }
    .paper-bg::before{ content:""; position:absolute; inset:0; background:linear-gradient(90deg, transparent 56px, var(--margin) 59px, transparent 62px); pointer-events:none }
    .paper-holes{ position:absolute; left:18px; top:96px; display:flex; flex-direction:column; gap:96px; pointer-events:none }
    .paper-hole{ width:18px; height:18px; border-radius:999px; background:var(--hole); box-shadow:inset 0 2px 4px rgba(0,0,0,.2) }
    .book{ perspective:1200px }
    .page{ transform-origin:left center; backface-visibility:hidden; transform-style:preserve-3d; transition:opacity .4s ease }
    .page.hidden{ opacity:0; pointer-events:none; transform:rotateY(-90deg) translateX(-20px) }
    .page.visible{ opacity:1; transform:rotateY(0); animation:pageFlipIn .6s ease both }
    .card{ background:rgba(255,255,255,.8); border:2px solid rgba(17,24,39,.1); border-radius:20px; padding:12px; box-shadow:0 12px 30px rgba(0,0,0,.07); backdrop-filter:blur(6px) }

    .hero{ position:relative; min-height:78vh; display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center }
    .ttv{ position:relative; display:inline-block }
    .ttv .word{ display:inline-block; transform-origin:50% 70%; animation:ttv-wobble 2.4s ease-in-out infinite }
    .ttv .word:nth-child(2){ animation-delay:.15s }
    .ttv .word:nth-child(3){ animation-delay:.3s }
    .ttv .accent{ display:inline-block; padding-inline:.15em; transform:rotate(-2deg); text-shadow:0 2px 0 #ffe4e6 }

    .ttv::before{
      content:""; position:absolute; inset:auto 0 -8px 0; height:28%;
      background:linear-gradient(90deg, rgba(244,63,94,.28), rgba(244,63,94,.6), rgba(244,63,94,.28));
      filter:blur(10px); transform-origin:left center; pointer-events:none;
      animation:inkSweep 1.4s ease-out .15s 1;
    }

    .note{ font-family:"Caveat", ui-serif; font-weight:800; background:#fff7cc; color:#0b1324; border-radius:.5rem; box-shadow:0 4px 0 rgba(0,0,0,.2); transform:rotate(-4deg); overflow:hidden; }
    .note-tiny{ font-size:clamp(30px,8vw,36px); padding:.05em .35em; min-width:auto; line-height:1.05; }
    .note-at-title{ position:absolute; left:-10px; top:-14px; z-index:5; }

    @keyframes ttv-wobble{ 0%,100%{ transform:translateY(0) } 25%{ transform:translateY(-4px) } 50%{ transform:translateY(2px) } 75%{ transform:translateY(-2px) } }

    .scribble{ width:min(920px,92vw); height:32px; margin-inline:auto }
    .scribble path{ stroke:rgba(239,68,68,.82); stroke-width:6; fill:none; stroke-linecap:round; stroke-dasharray:1400; animation:scribble 1.8s ease forwards, scribbleFlow 5s linear 2s infinite; filter: drop-shadow(0 0 6px rgba(239,68,68,.45)); }

    /* ===== Idle de ruido (video) ===== */
    .idle-video{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;        /* ocupa todo el contenedor */
      transform:scale(1.22);   /* más de cerca */
      z-index:2;
      pointer-events:none;     /* no bloquea clicks */
    }
    .hide{ display:none !important; }

    /* ====== VIDEO (REGLAS BASE) ====== */
    video{ width:100%; height:100%; background:#000; display:block; object-position:center center; -webkit-user-select:none; user-select:none; }
    video.mirror{ transform: scaleX(-1) }

   /* --- Desktop con aspect-ratio: no dependas de JS para altura --- */
.stage{ position:relative; width:100%; }
.layout-split{
  display:grid; grid-template-columns:1fr 1fr; gap:1rem;
}
.layout-split .tile{
  position:relative;
  border-radius:16px; overflow:hidden; background:#000;
  /* la altura la define el aspect-ratio */
  height:auto; 
  aspect-ratio: var(--box-ar);
  display:block;
}
/* fija el <video> pegado al tile, sin alterar layout */
.layout-split .tile video{
  position:absolute; inset:0; width:100%; height:100%;
}
    /* Local: SIEMPRE cubrir (sin bandas) */
    #stage .tile.local  video{ object-fit: cover; }
    
    /* Remoto: por defecto NO recortar */
    #stage .tile.remote video{ object-fit: contain; background:#000; }
    body.remote-portrait #stage .tile.remote video{ object-fit: cover; }

    /* ===== MÓVIL: FULL-BLEED MITAD/MITAD ===== */
    .layout-mobile-fixed{
      position:fixed; inset:0; height:calc(var(--dvh) * 100);
      display:grid; grid-template-rows:1fr 1fr; grid-template-columns:1fr;
      background:#000; z-index:0;
    }
    .pane{ position:relative; overflow:hidden; background:#000; }
    .pane video{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
    .pane video.contain{ object-fit: contain; background:#000; }

    /* Ocultar PiP en móvil y landing */
    .pip{ display:none !important; }

    /* Topbar (PC) */
    .topbar .btn{ border:2px solid rgba(17,24,39,.3); background:rgba(255,255,255,.9); padding:.5rem .9rem; border-radius:999px; font-weight:600; }
    .topbar .btn:disabled{ opacity:.55 }

    /* Botones fijos (MÓVIL) */
    .mobile-btn{
      position:fixed; bottom:calc(env(safe-area-inset-bottom,0) + 14px);
      z-index:60; border-radius:999px; padding:.78rem 1.05rem;
      border:2px solid rgba(255,255,255,.25); background:rgba(17,24,39,.7); color:#fff;
      font-weight:800; backdrop-filter:blur(6px); box-shadow:0 10px 28px rgba(0,0,0,.25);
    }
    #btn-buscar-m{ left:14px; }
    #btn-salir-m{ right:14px; }

   .overlay{
  position:absolute; inset:0;
  display:flex; align-items:center; justify-content:center;
  background:rgba(0,0,0,.25); z-index:20;
  pointer-events:none;
  opacity:0; visibility:hidden;
  transition: opacity .18s linear, visibility 0s linear .18s;
}
.overlay.show{
  opacity:1; visibility:visible;
  transition: opacity .18s linear;
}
 .idle-video{
  position:absolute; inset:0;
  width:100%; height:100%;
  object-fit:cover;
  transform:scale(1.22);
  z-index:2; pointer-events:none;
  opacity:1; visibility:visible;
  transition: opacity .12s linear, visibility 0s linear .12s;
}
.idle-video.hide{
  opacity:0; visibility:hidden;
  transition: opacity .12s linear;
}
    .overlay .card{ pointer-events:auto; } /* por si quieres hacer clic en algo dentro */

    .dot{ width:10px; height:10px; border-radius:999px; background:#ef4444; margin:0 4px; animation:b .9s infinite alternate }
    .dot:nth-child(2){ animation-delay:.15s } .dot:nth-child(3){ animation-delay:.3s }

    /* PC helpers */
    .full-bleed{ width:100vw; position:relative; left:50%; right:50%; margin-left:-50vw; margin-right:-50vw; }
    @media (min-width: 640px){
      .card.stretch{ height:100%; display:flex; flex-direction:column; }
      .card.stretch > .tile{ flex:1 1 auto; }
    }

    /* Móvil: oculta topbar y paddings cuando entras a sala */
    @media (max-width: 640px){
      .topbar{ display:none; }
      main{ padding:0 !important; }
      .book{ padding:0 !important; }
      .full-bleed{ margin:0; left:0; right:0; width:100%; }
    }

    /* ====== CONTROLES DE ZOOM (PC) ====== */
    .zoom-controls{ position:absolute; right:10px; bottom:10px; display:flex; gap:6px; z-index:20; }
    .zoom-btn{ width:30px; height:30px; border-radius:999px; display:grid; place-items:center; font-weight:800; background:rgba(255,255,255,.9); border:2px solid rgba(17,24,39,.35); box-shadow:0 8px 18px rgba(0,0,0,.18) }
    .zoom-btn:active{ transform:translateY(1px) }

    /* Asegura el clipping al hacer zoom */
    .tile video{ will-change:transform; }

    /* ===== Dock inferior SOLO en móviles ===== */
    .mobile-dock{
      position:fixed;
      left:12px; right:12px;
      bottom:calc(env(safe-area-inset-bottom,0) + 10px);
      z-index:60;
      display:grid; grid-template-columns:1fr 1fr; gap:10px;
      padding:10px;
      border-radius:18px;
      background:rgba(17,24,39,.55);
      backdrop-filter:blur(10px);
      box-shadow:0 16px 36px rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.18);
    }
    .dock-btn{ padding:.9rem 1rem; border-radius:999px; font-weight:800; border:2px solid transparent; -webkit-tap-highlight-color: transparent; }
    .dock-btn--primary{ background:#fff; color:#111; border-color:#ddd; }
    .dock-btn--ghost{ background:transparent; color:#fff; border-color:rgba(255,255,255,.4); }
    @media (min-width: 641px){ .mobile-dock{ display:none } }

    /* ============== AÑADIDOS (móvil estilo OmeTV) ============== */
    @media (max-width:640px){
      .mobile-dock{ display:none !important; }
      .topbar{ display:none !important; }
    }

    /* Botón mini cambiar cámara (abajo-izq) */
    .cam-switch{
      position:fixed; left:12px;
      bottom:calc(env(safe-area-inset-bottom,0) + 12px);
      z-index:70; width:42px; height:42px; border-radius:999px;
      display:grid; place-items:center; font-size:18px; font-weight:900;
      background:rgba(17,24,39,.75); color:#fff; border:2px solid rgba(255,255,255,.25);
      backdrop-filter:blur(8px); box-shadow:0 10px 28px rgba(0,0,0,.28);
      -webkit-tap-highlight-color: transparent;
    }
    @media (min-width:641px){ .cam-switch{ display:none } }

    /* Pantalla estática (cuando no hay stream o esperando) */
    .idle{
      position:absolute; inset:0; display:grid; place-items:center;
      background:#000; color:#fff; text-align:center; font-weight:800;
      text-shadow:0 2px 10px rgba(0,0,0,.6); z-index:1;
    }
    .idle.hide{ display:none; }

    .static-noise{ 
      background:
        repeating-linear-gradient(0deg, rgba(255,255,255,.05) 0 2px, transparent 2px 4px),
        repeating-linear-gradient(90deg, rgba(255,255,255,.035) 0 2px, transparent 2px 3px),
        #000;
      animation:tvNoise 1s steps(8) infinite;
    }
    @keyframes tvNoise{
      0%{ filter:contrast(140%) brightness(115%); }
      100%{ filter:contrast(140%) brightness(115%); transform:translateY(-1px); }
    }

    /* Ocultamos tip "desliza" porque ahora hay cubo + sway */
    .swipe-tip{ display:none !important; }

    /* ====== Móvil: engranaje ajustes (mute) ====== */
    .gear-btn{
  position:fixed; left:12px; top:calc(env(safe-area-inset-top,0) + 12px);
  z-index:80; width:42px; height:42px; border-radius:999px;
  display:grid; place-items:center; font-size:18px; font-weight:900;
  background:rgba(17,24,39,.75); color:#fff; border:2px solid rgba(255,255,255,.25);
  backdrop-filter:blur(8px); box-shadow:0 10px 28px rgba(0,0,0,.28);
}
    @media (min-width:641px){ .gear-btn{ display:none } }

    .sheet{
      position:fixed; right:12px; top:60px; z-index:81;
      background:rgba(17,24,39,.92); color:#fff; border-radius:14px;
      border:1px solid rgba(255,255,255,.2); padding:10px 12px; min-width:180px;
      box-shadow:0 16px 36px rgba(0,0,0,.35); display:none;
    }
    .sheet.show{ display:block; }
    .sheet .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; padding:6px 2px; }
    .switch{ appearance:none; width:40px; height:22px; border-radius:999px; position:relative; background:#444; outline:none; cursor:pointer; }
    .switch:checked{ background:#22c55e; }
    .switch::after{ content:""; position:absolute; top:3px; left:3px; width:16px; height:16px; border-radius:999px; background:#fff; transition:left .2s; }
    .switch:checked::after{ left:21px; }

    /* Topbar new controls spacing (PC) */
    .topbar .sep{ width:1px; height:24px; background:rgba(0,0,0,.15); margin:0 6px; }

    /* ====== PAN L↔R del idle en móvil (solo SALA) ====== */
    @media (max-width:640px){
      #idleNoiseM.lr-pan{
        will-change: transform;
        animation: noisePan 1.8s ease-in-out infinite alternate;
        -webkit-animation: noisePan 1.8s ease-in-out infinite alternate;
      }
      @keyframes noisePan{
        0%   { transform: scale(1.22) translateX(-6%); }
        100% { transform: scale(1.22) translateX( 6%); }
      }
      @-webkit-keyframes noisePan{
        0%   { -webkit-transform: scale(1.22) translateX(-6%); }
        100% { -webkit-transform: scale(1.22) translateX( 6%); }
      }
    }

    /* ===== Emojis en overlay ===== */
    .emoji-layer{
      position:absolute; inset:0; pointer-events:none; overflow:hidden;
    }
    .swipe-emoji{
      position:absolute; font-size:18px;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,.35));
      opacity:0; transform: translate3d(0,0,0) scale(0.9) rotate(0deg);
      animation: emojiFloat .95s ease-out forwards;
    }
    @keyframes emojiFloat{
      0%   { opacity:0; transform: translateY(6px) scale(.9) rotate(0deg); }
      20%  { opacity:1; }
      100% { opacity:0; transform: translateY(-26px) scale(1.06) rotate(12deg); }
    }

    /* ===== Cubo 3D + bamboleo remoto (solo móvil) ===== */
    @media (max-width:640px){
      .cube-hint{ display:none !important; } /* ← oculto definitivamente en móvil */
      .cube{
        --cube: min(44vw, 44vh);
        --z: calc(var(--cube) / 2);
        width: var(--cube); height: var(--cube);
        transform-style: preserve-3d;
        animation: cubeSpin 3.2s ease-in-out infinite;
      }
      .cube .face{
        position:absolute; inset:0; display:grid; place-items:center;
        font-size:clamp(22px, 8vw, 36px); font-weight:900; color:#fff;
        background:rgba(17,24,39,.22); border:1px solid rgba(255,255,255,.15);
        border-radius:14px; backdrop-filter: blur(6px);
      }
      .cube .front  { transform: translateZ(var(--z)); }
      .cube .back   { transform: rotateY(180deg) translateZ(var(--z)); }
      .cube .left   { transform: rotateY(-90deg) translateZ(var(--z)); }
      .cube .right  { transform: rotateY(90deg) translateZ(var(--z)); }
      .cube .top    { transform: rotateX(90deg) translateZ(var(--z)); }
      .cube .bottom { transform: rotateX(-90deg) translateZ(var(--z)); }

      @keyframes cubeSpin{
        0%   { transform: rotateX(-12deg) rotateY(0deg); }
        50%  { transform: rotateX(12deg)  rotateY(180deg); }
        100% { transform: rotateX(-12deg) rotateY(360deg); }
      }

      /* bamboleo del remoto mientras está buscando */
      #pane-remote.searching{ animation: remoteSway 1.6s ease-in-out infinite; }
      @keyframes remoteSway{
        0%   { transform: translateX(-2%) rotateZ(-0.3deg); }
        50%  { transform: translateX( 2%) rotateZ( 0.3deg); }
        100% { transform: translateX(-2%) rotateZ(-0.3deg); }
      }
    }

    /* ===== Mano fantasma (móvil, idle) ===== */
    @media (max-width:640px){
  .swipe-ghost{
    position:absolute; inset:0; pointer-events:none; z-index:22;
    display:none; /* .show => visible */
  }
  .swipe-ghost.show{ display:block; }

  .swipe-ghost .hand{
    position:absolute;
    left:14px; top:40%;
    transform: translateY(-50%);
    width: clamp(160px, 30vw, 240px);
    opacity:.85;
    filter: drop-shadow(0 6px 14px rgba(0,0,0,.4));
    animation: ghostSeq 2.6s ease-in-out infinite;
    transform-origin: left center;
  }

  @keyframes ghostSeq{
    0%   { transform: translateY(-50%) translateX(0) scale(.9);  opacity:0; }
    10%  { transform: translateY(-50%) translateX(0) scale(1.05); opacity:.95; }
    20%  { transform: translateY(-50%) translateX(0) scale(1.0); opacity:.8; }
    50%  { transform: translateY(-50%) translateX(120px) scale(1); opacity:.4; } /* Izq→Der */
    60%  { transform: translateY(-50%) translateX(120px) scale(.98); opacity:0; }
    100% { transform: translateY(-50%) translateX(0) scale(.96); opacity:0; }
  }
}
/* ===== Admin Badge ===== */
.admin-badge{
  position:fixed; top:12px; right:12px; z-index:1000;
  border-radius:999px; padding:.45rem .8rem;
  font-weight:800; font-size:.85rem; line-height:1;
  border:2px solid rgba(0,0,0,.18);
  box-shadow:0 10px 26px rgba(0,0,0,.16), inset 0 0 0 9999px rgba(255,255,255,.08);
  display:flex; align-items:center; gap:.45rem;
  -webkit-tap-highlight-color: transparent;
  user-select:none;
}
.admin-badge .badge-inner{ position:relative; display:flex; align-items:center; gap:.45rem; }
.admin-badge .badge-icon{ font-size:1rem; transform:translateY(1px); }
.admin-badge .badge-text{ letter-spacing:.4px; }

/* Estado: NO admin (gris con candado) */
.admin-badge.admin-off{
  background:linear-gradient(180deg,#f3f4f6,#e5e7eb);
  color:#111827;
  cursor:pointer;
}
.admin-badge.admin-off .badge-icon{ filter:grayscale(1) opacity(.9); }

/* Estado: admin (dorado-morado con brillo + partículas) */
.admin-badge.admin-on{
  background: linear-gradient(135deg,#fbbf24 0%, #f59e0b 22%, #a855f7 70%, #7c3aed 100%);
  color:#fff;
  border-color: rgba(255,255,255,.28);
  box-shadow:
    0 12px 30px rgba(124,58,237,.35),
    0 0 0 1px rgba(255,255,255,.12) inset,
    0 0 22px rgba(168,85,247,.55);
  animation: badgePulse 2.2s ease-in-out infinite;
}
@keyframes badgePulse{
  0%,100%{ transform: translateZ(0) scale(1); }
  50%    { transform: translateZ(0) scale(1.03); }
}

/* Efecto “shine” que cruza */
.admin-badge.admin-on::after{
  content:""; position:absolute; inset:-2px;
  background:linear-gradient(120deg, transparent 40%, rgba(255,255,255,.45) 50%, transparent 60%);
  filter: blur(1px);
  transform: translateX(-120%);
  animation: shine 3.6s ease-in-out infinite;
  border-radius:inherit; pointer-events:none;
}
@keyframes shine{
  0%{ transform: translateX(-120%); opacity:.0; }
  45%{ opacity:.0; }
  55%{ opacity:.8; }
  100%{ transform: translateX(120%); opacity:0; }
}

/* Partículas sutiles (sólo admin) */
.sparkles{
  position:absolute; inset:-6px; pointer-events:none;
  background:
    radial-gradient(circle at 12% 30%, rgba(255,255,255,.85) 0 2px, transparent 3px) no-repeat,
    radial-gradient(circle at 78% 40%, rgba(255,255,255,.75) 0 1.8px, transparent 2.8px) no-repeat,
    radial-gradient(circle at 52% 18%, rgba(255,255,255,.9) 0 1.6px, transparent 2.6px) no-repeat,
    radial-gradient(circle at 66% 74%, rgba(255,255,255,.7) 0 2px, transparent 3px) no-repeat,
    radial-gradient(circle at 28% 68%, rgba(255,255,255,.7) 0 1.6px, transparent 2.6px) no-repeat;
  animation: twinkle 2.2s linear infinite;
  opacity:0; /* apagado por defecto, se enciende en .admin-on */
}
.admin-badge.admin-on .sparkles{ opacity:1; }
@keyframes twinkle{
  0%   { transform: translateY(0);   filter: drop-shadow(0 0 6px rgba(255,255,255,.5)); }
  50%  { transform: translateY(-1px); filter: drop-shadow(0 0 10px rgba(255,255,255,.9)); }
  100% { transform: translateY(0);    filter: drop-shadow(0 0 6px rgba(255,255,255,.5)); }
  
}
/* efecto visual de click del badge */
.admin-badge:active{
  transform: translateY(1px);
}
/* ===== GAZE bubble (estilo “burbuja real”) ===== */
.gaze-layer{ position:absolute; inset:0; pointer-events:none; z-index:26; }

.gaze-bubble{
  position:absolute;
  width:30px; height:30px;
  border-radius:999px;
  /* cuerpo translúcido con sutil color azulado */
  background:
    radial-gradient(40% 40% at 30% 30%, rgba(255,255,255,.95), rgba(255,255,255,.35) 60%, rgba(255,255,255,0) 100%),
    radial-gradient(90% 90% at 60% 70%, rgba(173,216,230,.25), rgba(255,255,255,0) 70%);
  /* borde interior + sombra suave para “volumen” */
  box-shadow:
    0 8px 16px rgba(0,0,0,.18),
    inset 0 0 0 1.5px rgba(255,255,255,.9),
    inset 0 0 18px rgba(255,255,255,.18);
  backdrop-filter: blur(2px);
  -webkit-backdrop-filter: blur(2px);

  transform: translate(-50%,-50%) scale(1);
  transform-origin: 50% 50%;
  opacity: 0;
  will-change: transform, opacity, filter;
  transition: opacity .12s linear;
}

/* brillo especular “gota” */
.gaze-bubble::after{
  content:"";
  position:absolute; inset:0;
  background:
    radial-gradient(60% 40% at 28% 28%, rgba(255,255,255,.9), rgba(255,255,255,0) 60%);
  border-radius:inherit;
  filter: blur(0.4px);
  pointer-events:none;
}

/* iridiscencia muy sutil */
.gaze-bubble::before{
  content:"";
  position:absolute; inset:-2px;
  border-radius:inherit;
  background: conic-gradient(
    from 0deg,
    rgba(255,0,128,.10),
    rgba(0,128,255,.10),
    rgba(0,255,180,.10),
    rgba(255,255,0,.10),
    rgba(255,0,128,.10)
  );
  mix-blend-mode: soft-light;
  filter: blur(6px) saturate(115%);
  opacity:.65;
  pointer-events:none;
}

.gaze-bubble.show{ opacity:1; }

  </style>
</head>
<body class="font-sans ar-1-1">
  <!-- BADGE ADMIN (siempre visible) -->
<button id="adminBadge" type="button" aria-label="Administrador"
  class="admin-badge admin-off">
  <span class="badge-inner">
    <span class="badge-icon" aria-hidden="true">🔒</span>
    <span class="badge-text">Admin</span>
    <!-- partículas sólo para admin -->
    <span class="sparkles" aria-hidden="true"></span>
  </span>
</button>
  <div class="paper-bg">
    <div class="paper-holes"><div class="paper-hole"></div><div class="paper-hole"></div><div class="paper-hole"></div></div>
    
    <main class="book mx-auto max-w-5xl px-6 py-10">
      <!-- LANDING -->
      <section id="page-landing" class="page visible">
        <div class="hero">
          <h1 class="font-display font-extrabold select-none ttv animate-wobbleIn" style="font-size:clamp(56px,10vw,140px); line-height:.9; text-shadow:0 1px 0 #fff, 0 10px 18px rgba(0,0,0,.15)">
            <span class="note note-tiny note-at-title">
              <span class="scroller" id="noteScroller">
                <span class="slide" id="noteCurr">anal</span>
                <span class="slide" id="noteNext" style="margin-left:1ch">—</span>
              </span>
            </span>
            <span class="word">Tortilla</span><span class="accent text-rose-600">TV</span>
          </h1>

          <p class="mt-4 text-neutral-700 text-lg">Video chat aleatorio</p>

          <!-- Género -->
          <div class="mt-6 grid grid-cols-3 gap-3 max-w-md">
            <button data-gen="Hombre" class="gen card py-4 flex flex-col items-center gap-2">
              <svg width="26" height="26" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M14.5 3H21v6" stroke="#111827" stroke-width="1.8" stroke-linecap="round"/><path d="M21 3l-7.5 7.5" stroke="#111827" stroke-width="1.8" stroke-linecap="round"/><circle cx="9" cy="15" r="5.5" stroke="#111827" stroke-width="1.8"/></svg>
              <span class="font-semibold">Macho</span>
            </button>
            <button data-gen="Tortillera" class="gen card py-4 flex flex-col items-center gap-2">
              <svg width="26" height="26" viewBox="0 0 24 24" fill="none" aria-hidden="true"><circle cx="12" cy="8" r="5.5" stroke="#111827" stroke-width="1.8"/><path d="M12 13.5v6M9.5 17h5" stroke="#111827" stroke-width="1.8" stroke-linecap="round"/></svg>
              <span class="font-semibold">Tortillera</span>
            </button>
            <button data-gen="Lada" class="gen card py-4 flex flex-col items-center gap-2">
              <svg width="26" height="26" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M4 14l2-5h12l2 5v4a1 1 0 0 1-1 1h-1" stroke="#111827" stroke-width="1.8" stroke-linejoin="round"/><circle cx="8" cy="19" r="1.6" fill="#111827"/><circle cx="18" cy="19" r="1.6" fill="#111827"/><path d="M6 14h12" stroke="#111827" stroke-width="1.8" stroke-linecap="round"/></svg>
              <span class="font-semibold">Un Lada</span>
            </button>
          </div>
          <p id="genElegido" class="mt-2 text-sm text-neutral-600"></p>

          <!-- Form extra: nombre y edad (aparece tras elegir sexo) -->
          <div id="extraForm" class="mt-4 max-w-md w-full grid grid-cols-1 gap-3" style="display:none">
            <label class="card flex items-center gap-3">
              <svg width="22" height="22" viewBox="0 0 24 24" fill="none" aria-hidden="true"><circle cx="12" cy="8" r="4" stroke="#111827" stroke-width="1.6"/><path d="M4 20c1.6-3.2 4.7-5 8-5s6.4 1.8 8 5" stroke="#111827" stroke-width="1.6" stroke-linecap="round"/></svg>
              <input id="inpNombre" class="w-full bg-transparent outline-none" type="text" placeholder="Tu nombre" maxlength="32">
            </label>
            <label class="card flex items-center gap-3">
              <svg width="22" height="22" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M7 7h10M7 12h10M7 17h6" stroke="#111827" stroke-width="1.6" stroke-linecap="round"/><rect x="3" y="4" width="18" height="16" rx="2" stroke="#111827" stroke-width="1.6"/></svg>
              <input id="inpEdad" class="w-full bg-transparent outline-none" type="number" inputmode="numeric" min="18" max="99" placeholder="Edad (18+)" />
            </label>
          </div>

          <!-- Google login -->
          <button id="btn-google" class="mt-6 rounded-xl border-2 border-neutral-900/40 bg-white/90 px-7 py-3.5 font-semibold shadow disabled:opacity-50" disabled>
            Iniciar con Google
          </button>
           <button id="btn-guest"
  class="mt-3 rounded-xl border-2 border-neutral-900/40 bg-white/90 px-7 py-3.5 font-semibold shadow">
  Entrar como invitado
</button>
          <svg class="scribble mt-6" viewBox="0 0 1200 100" preserveAspectRatio="none" aria-hidden="true">
            <path d="M10,70 C200,20 400,120 600,60 C800,0 1000,120 1190,50"/>
          </svg>
        </div>
      </section>

      <!-- SALA -->
      <section id="page-chat" class="page hidden">
        <!-- Topbar PC -->
        <div class="card p-3 mb-4 topbar">
          <div class="flex flex-wrap items-center gap-2">
            <button id="btn-start" class="btn">Buscar</button>
            <button id="btn-next"  class="btn" disabled>Siguiente</button>
            <button id="btn-stop"  class="btn" disabled>Detener</button>
            <span class="sep"></span>
            <!-- NUEVOS BOTONES PC -->
            <button id="btn-mute"  class="btn" disabled>Mute</button>
            <button id="btn-cam"   class="btn" disabled>Apagar cam</button>
            <button id="btn-eye" class="btn hidden" title="Ver mirada de la pareja">👁</button>
            <button id="btn-cupid" class="btn hidden" title="Modo Cupido">💘 Cupido</button>
<button id="btn-cupid-off" class="btn hidden" title="Salir Cupido">Salir Cupido</button>


            <div class="ml-auto flex items-center gap-2">
              <button id="btn-ar" class="btn">AR: 1:1</button>
            </div>

            <div class="flex items-center gap-2 text-sm w-full">
              <span id="status" class="text-neutral-700">Listo</span>
              <span id="peerLabel" class="text-neutral-700 hidden">Pareja: —</span>
              <span id="you-badge" class="ml-auto text-xs px-2 py-1 rounded-full border border-black/20 bg-white/70 hidden">Tú: —</span>
            </div>
          </div>
        </div>

       <!-- Video PC y contenedor móvil -->
<div id="videoShell" class="full-bleed">
  <!-- PC: 50/50 -->
  <div id="stage" class="stage layout-split">
    <!-- REMOTO (PC) -->
    <div class="tile remote" id="remoteTile">
      <video id="idleNoiseD" class="idle-video"
             src="./assets/noise.mp4" muted playsinline autoplay loop preload="auto"></video>
      <video id="remoteVideo" autoplay playsinline></video>
     <!-- BOTÓN SIGUIENTE (IZQUIERDA) -->
<button id="btn-next-left"
  class="absolute top-2 left-2 z-30 bg-white/90 border-2 border-black/20 rounded-full px-3 py-1 text-sm font-semibold hidden">
  ⟳ Siguiente
</button>

      <!-- OVERLAY PC -->
      <div id="overlayD" class="overlay">
        <div class="card px-5 py-4 flex items-center gap-3 bg-white">
          <span class="font-semibold">Buscando tortilleras!!!…</span>
          <div class="flex"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
        </div>
        <div class="emoji-layer" aria-hidden="true"></div>
      </div>

      <!-- ZOOM REMOTO (PC) -->
      <div class="zoom-controls sm:flex hidden" aria-label="Zoom remoto">
        <button id="fitRemote" class="zoom-btn" title="Ver completo">⤢</button>
        <button id="zoomOutRemote" class="zoom-btn" title="Alejar">−</button>
        <button id="zoomInRemote" class="zoom-btn" title="Acercar">+</button>
      </div>
    </div>
   <!-- REMOTO DERECHO (PC · CUPIDO) -->
<div class="tile remote" id="remoteTileR" style="display:none">
  <video id="idleNoiseD_R" class="idle-video"
         src="./assets/noise.mp4" muted playsinline autoplay loop preload="auto"></video>
  <video id="remoteVideoR" autoplay playsinline></video>

  <!-- BOTÓN SIGUIENTE (DERECHA) -->
  <button id="btn-next-right"
    class="absolute top-2 left-2 z-30 bg-white/90 border-2 border-black/20 rounded-full px-3 py-1 text-sm font-semibold hidden">
    ⟳ Siguiente
  </button>

  <!-- OVERLAY (buscando) -->
  <div id="overlayD_R" class="overlay">
    <div class="card px-5 py-4 flex items-center gap-3 bg-white">
      <span class="font-semibold">Buscando maricones…</span>
      <div class="flex"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
    </div>
  </div>

  <!-- ZOOM REMOTO DERECHO -->
  <div class="zoom-controls sm:flex hidden" aria-label="Zoom remoto derecho">
    <button id="fitRemoteR" class="zoom-btn" title="Ver completo">⤢</button>
    <button id="zoomOutRemoteR" class="zoom-btn" title="Alejar">−</button>
    <button id="zoomInRemoteR" class="zoom-btn" title="Acercar">+</button>
  </div>
</div>

    <!-- LOCAL (PC) -->
    <div class="tile local" id="localTile">
      <video id="localVideo" autoplay playsinline muted class="mirror"></video>

      <!-- ZOOM LOCAL (PC) -->
      <div class="zoom-controls sm:flex hidden" aria-label="Zoom local">
        <button id="resetLocal" class="zoom-btn" title="Reset">⟲</button>
        <button id="zoomOutLocal" class="zoom-btn" title="Alejar">−</button>
        <button id="zoomInLocal" class="zoom-btn" title="Acercar">+</button>
      </div>

      <!-- GAZE bubble (PC) -->
      <div class="gaze-layer" id="gazeLayerLocalD" aria-hidden="true">
        <div class="gaze-bubble" id="gazeBubbleLocalD"></div>
      </div>
    </div>
  </div><!-- /#stage -->

 <!-- PiP ADMIN (PC · Cupido) pequeño, centrado arriba sobre ambas pantallas -->
<div id="pip" style="
  display:none;
  position:fixed;           
  left:50%;                  /* centro horizontal */
  top:0;                     /* lo colocamos por JS justo sobre los tiles */
  transform:translate(-50%, 0);
   width:clamp(220px, 18vw, 360px);
  aspect-ratio:4/3;
  z-index:100;               /* por encima de los dos videos */
  border-radius:14px;
  overflow:hidden;
  box-shadow:0 12px 26px rgba(0,0,0,.28);
  border:1px solid rgba(255,255,255,.45);
  background:#000;
">
  <video id="pipVideo" autoplay playsinline muted
         style="width:100%;height:100%;object-fit:cover;"></video>
</div>


     
  <!-- MÓVIL: pantalla partida full-bleed -->
  <div id="stageMobile" class="layout-mobile-fixed" style="display:none;">
    <div class="pane" id="pane-remote">
      <video id="idleNoiseM" class="idle-video"
             src="./assets/noise.mp4" muted playsinline autoplay loop preload="auto"></video>
      <video id="remoteVideoM" autoplay playsinline></video>

      <div id="overlayM" class="overlay">
        <div class="card px-5 py-4 flex items-center gap-3 bg-white">
          <span class="font-semibold">Buscando tortilleras!!!…</span>
          <div class="flex"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
        </div>
        <div class="emoji-layer" aria-hidden="true"></div>
      </div>

      <div id="swipe-ghost" class="swipe-ghost sm:hidden" aria-hidden="true">
        <img src="assets/hand.png" alt="hand" class="hand" />
      </div>
    </div>

    <div class="pane" id="pane-local">
      <div id="idle-local" class="idle static-noise"><div>Preparando cámara…</div></div>
      <video id="localVideoM" autoplay playsinline muted class="mirror"></video>

      <!-- GAZE bubble (Móvil) -->
      <div class="gaze-layer" id="gazeLayerLocalM" aria-hidden="true">
        <div class="gaze-bubble" id="gazeBubbleLocalM"></div>
      </div>
    </div>
  <!-- MINI SIDE (MÓVIL · Cupido, sin 'Siguiente') -->
<div id="cupidMini" style="
  position:fixed;
  left:12px; bottom:calc(env(safe-area-inset-bottom,0) + 74px);
  width:min(42vw, 42vh * 4 / 3);
  aspect-ratio: 4 / 3;
  border-radius:14px; overflow:hidden;
  box-shadow:0 16px 36px rgba(0,0,0,.35);
  z-index:62; 
  display:none;
  background:#000;
">
  <video id="idleNoiseM_R" class="idle-video"
         src="./assets/noise.mp4" muted playsinline autoplay loop preload="auto"></video>
  <video id="remoteVideoR_M" autoplay playsinline></video>

  <div id="overlayM_R" class="overlay show">
    <div class="card px-4 py-3 flex items-center gap-3 bg-white">
      <span class="font-semibold">Buscando maricones</span>
      <div class="flex"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
    </div>
  </div>
</div>

  </div><!-- /#stageMobile -->
</div><!-- /#videoShell -->


        <!-- Dock inferior SOLO en móviles (queda en DOM pero se oculta en móvil) -->
        <div class="mobile-dock sm:hidden" role="toolbar" aria-label="Controles de sala">
          <button id="btn-buscar-m" class="dock-btn dock-btn--primary">Buscar sala</button>
          <button id="btn-salir-m" class="dock-btn dock-btn--ghost">Salir</button>
        </div>

        <!-- Botón salir extra (PC / fallback) -->
        <div class="mt-6 flex items-center justify-center">
          <button id="btn-salir-chat" class="rounded-full border-2 border-neutral-900/30 bg-white/80 px-5 py-2 text-sm font-semibold shadow">Salir</button>
        </div>

        <!-- Tip de gesto (móvil) — oculto por CSS -->
        <div id="swipe-tip" class="swipe-tip sm:hidden">
          <div class="swipe-hand" aria-hidden="true"></div>
          <span>Desliza → empezar / siguiente — ← detener</span>
        </div>
      </section>
    </main>
  </div>

  <!-- Botón mini: cambiar cámara (móvil) -->
  <button id="btn-swapcam" class="cam-switch" aria-label="Cambiar cámara">↻</button>

  <!-- Engranaje ajustes (móvil) -->
  <button id="btn-gear" class="gear-btn" aria-label="Ajustes">⚙</button>
  <div id="gear-sheet" class="sheet">
    <div class="row"><span>Mute micrófono</span><input id="sw-mute" type="checkbox" class="switch"></div>
  </div>

  
 <script>
    /* ==== Viewport fix cross-browser ==== */
    function setVHVars(){
      const h = window.innerHeight;
      document.documentElement.style.setProperty('--dvh', h / 100 + 'px');
    }
    setVHVars();
    window.addEventListener('resize', setVHVars);
    window.addEventListener('orientationchange', setVHVars);

    // Limpiar highlight por hash
    window.addEventListener('DOMContentLoaded', () => {
      if (location.hash) history.replaceState(null, document.title, location.pathname + location.search);
    });

    // WS dinámico
    (function(){
      const p = new URLSearchParams(location.search);
      const wsOverride = p.get('ws');
      window.WS_SIGNALLING_URL = wsOverride || ((location.protocol === 'https:') ? `wss://${location.host}` : `ws://${location.host}`);
    })();

    // Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyBVuvV7NOaqkN6arT3xPTBdxMZg7TTPhlM",
      authDomain: "tortillatv-bf0c6.firebaseapp.com",
      projectId: "tortillatv-bf0c6",
      storageBucket: "tortillatv-bf0c6.firebasestorage.app",
      messagingSenderId: "193994912181",
      appId: "1:193994912181:web:03464c47f30fc5ac4d69fc"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();

    /* ===== Helpers UI ===== */
    const pages = { landing: qs('#page-landing'), chat: qs('#page-chat') };
    function qs(s,root=document){ return root.querySelector(s) }
    function show(k){ Object.values(pages).forEach(p=>{p.classList.add('hidden');p.classList.remove('visible')}); pages[k].classList.remove('hidden'); pages[k].classList.add('visible'); window.scrollTo({top:0,behavior:'smooth'}) }
    function setStatus(t){ const el=qs('#status'); if(el) el.textContent=t }
    function safePlay(v){ try{ const p=v?.play?.(); if(p?.catch) p.catch(()=>{}); }catch{} }

    // === Overlay acoplado al REMOTO (PC/Móvil) ===
    function overlayEl(){
      return (layoutMode === 'split')
        ? document.getElementById('overlayD')
        : document.getElementById('overlayM');
    }
    function overlayEmojiLayer(){
      const root = overlayEl();
      return root ? root.querySelector('.emoji-layer') : null;
    }
    let searchEmojiTimer = null;
    const EMOJIS = ['👋','💬','🎭','🎥','✨','😄','🤝','🍀','🧑‍🤝‍🧑','🌟'];
    function spawnSearchEmoji(){
      const layer = overlayEmojiLayer(); if(!layer) return;
      const span = document.createElement('span');
      span.className = 'swipe-emoji';
      span.textContent = EMOJIS[Math.floor(Math.random()*EMOJIS.length)];

      // posición aleatoria dentro del overlay remoto
      const rect = layer.getBoundingClientRect();
      const x = Math.random() * rect.width;
      const y = Math.random() * rect.height * 0.6 + rect.height*0.2;
      span.style.left = x + 'px';
      span.style.top  = y + 'px';

      // ligera deriva horizontal
      const dir = Math.random() < .5 ? -1 : 1;
      span.animate(
        [
          { transform:`translate(${dir*4}px, 6px) scale(.9)`, opacity:0 },
          { transform:`translate(${dir*14}px, -26px) scale(1.06) rotate(12deg)`, opacity:1 },
          { transform:`translate(${dir*20}px, -36px) scale(1.06) rotate(18deg)`, opacity:0 }
        ],
        { duration: 950, easing: 'ease-out', fill: 'forwards' }
      );

      layer.appendChild(span);
      setTimeout(()=> span.remove(), 980);
    }
    function startSearchEmojis(){
      stopSearchEmojis();
      // ritmo agradable mientras se busca
      searchEmojiTimer = setInterval(spawnSearchEmoji, 420);
    }
    function stopSearchEmojis(){
      if(searchEmojiTimer){ clearInterval(searchEmojiTimer); searchEmojiTimer=null; }
    }
    function overlayShow(show){
      const ov = overlayEl(); if(!ov) return;
      ov.classList.toggle('show', !!show);
      if(show) startSearchEmojis(); else stopSearchEmojis();

      // bamboleo del remoto en móvil mientras se busca
      const pane = document.getElementById('pane-remote');
      if(pane){ pane.classList.toggle('searching', !!show); }

      // 👇 Mano fantasma: si aparece overlay (buscando), ocultar; si se cierra, reevaluar
      if (show) setGhostVisible(false); else updateGhostHandVisibility();
    }

    const peerLabel = qs('#peerLabel');
    const youBadge  = qs('#you-badge');

    /* ===== Letrero con deslizamiento unísono ===== */
    const NOTE_WORDS = ["anal","beso","charla","broma","random","a ochoa lo fusilaron","aayyyy","ya se me olvido que era singar","dame promo","https://instagram.com/marquisdsad3"];
    let noteIdx = 0;
    const scroller = document.getElementById('noteScroller');
    const noteCurr = document.getElementById('noteCurr');
    const noteNext = document.getElementById('noteNext');

    function cycleNote(){
      if(!scroller) return;
      const nextText = NOTE_WORDS[(noteIdx+1) % NOTE_WORDS.length];
      noteNext.textContent = nextText;

      scroller.style.transform = 'translateX(0%)';
      void scroller.offsetWidth;
      scroller.style.transition = 'transform .7s cubic-bezier(.22,.61,.36,1)';
      scroller.style.transform = 'translateX(-100%)';

      scroller.addEventListener('transitionend', onEnded, { once:true });
      function onEnded(){
        noteIdx = (noteIdx+1) % NOTE_WORDS.length;
        noteCurr.textContent = nextText;
        scroller.style.transition = 'none';
        scroller.style.transform = 'translateX(0%)';
      }
    }
    setInterval(cycleNote, 2200);

    /* ===== Estado landing + auth ===== */
    let chosenGender=null;
    const genButtons=[...document.querySelectorAll('.gen')];
    const genElegido=qs('#genElegido');
    const btnGoogle=qs('#btn-google');
    const extraForm=qs('#extraForm');
    const inpNombre=qs('#inpNombre');
    const inpEdad=qs('#inpEdad');

    function validateLoginEnable(){ btnGoogle.disabled = !chosenGender; }

    genButtons.forEach(b=>{
      b.addEventListener('click', ()=>{
        genButtons.forEach(x=>x.classList.remove('ring','ring-rose-400'));
        b.classList.add('ring','ring-rose-400');
        chosenGender=b.getAttribute('data-gen');
        genElegido.textContent='Has elegido: '+chosenGender;
        extraForm.style.display='grid';
        validateLoginEnable();
      });
    });

    [inpNombre, inpEdad].forEach(el=>{
      el?.addEventListener('input', ()=>{
        localStorage.setItem('ttv_name', inpNombre.value||'');
        localStorage.setItem('ttv_age',  inpEdad.value||'');
      });
    });

    /* ===== Refs ===== */
    const btnStart=qs('#btn-start'), btnNext=qs('#btn-next'), btnStop=qs('#btn-stop'), btnSalirChat=qs('#btn-salir-chat');
    const btnMute = qs('#btn-mute'), btnCam = qs('#btn-cam'), btnEye = qs('#btn-eye');

    const localVideo=qs('#localVideo'), remoteVideo=qs('#remoteVideo'), pip=qs('#pip'), pipVideo=qs('#pipVideo');
    const localVideoM=qs('#localVideoM'), remoteVideoM=qs('#remoteVideoM');
    const localTile = qs('#localTile');

    // ===== Cupido (PC) =====
let cupidOn = false;
let pcR = null;                    // PeerConnection SIDE (PC)
let remoteStreamRefR = null;

const remoteTileR  = qs('#remoteTileR');
const remoteVideoR = qs('#remoteVideoR');
const idleNoiseD_R = qs('#idleNoiseD_R');
const overlayD_R   = qs('#overlayD_R');

const btnNextLeft  = qs('#btn-next-left');
const btnNextRight = qs('#btn-next-right');
const btnCupid     = qs('#btn-cupid');
const btnCupidOff  = qs('#btn-cupid-off');
// === Arranque/paro de Cupido en PC ===
function startCupid(){
  if (!IS_ADMIN || cupidOn) return;
  cupidOn = true;

  // Mostrar PiP centrado 4:3 (tu cámara) y el panel derecho buscando
  const pipEl = qs('#pip'); if (pipEl) pipEl.style.display = '';
  // ↓ Baja el PiP debajo de la topbar y mantenlo anclado
positionPipBelowTopbar();
window.addEventListener('resize', positionPipBelowTopbar);
window.addEventListener('scroll', positionPipBelowTopbar, { passive: true });

  // Ocultar la vista local grande (solo PC) para que se vea SOLO el PiP
if (!isMobile()) { localTile && (localTile.style.display = 'none'); }

  showRightSearchingUI(true);

  // Ocultar controles que no tocan durante cupido
  btnMute?.classList.add('hidden');
  btnCam?.classList.add('hidden');
  btnAR ?.classList.add('hidden');

  // Avisar al server y pedir emparejamiento SIDE
  connectWS().then(()=>{
    send({ type:'cupid-on' });
    send({ type:'cupid-find' });
  }).catch(()=>{});
}

function stopCupid(){
  if (!cupidOn) return;
  cupidOn = false;
// Volver a mostrar la vista local grande
if (!isMobile()) { localTile && (localTile.style.display = ''); }

  // Ocultar PiP y panel derecho; restaurar controles
  const pipEl = qs('#pip'); if (pipEl) pipEl.style.display = 'none';
  showRightSearchingUI(false);
  btnMute?.classList.remove('hidden');
  btnCam ?.classList.remove('hidden');
  btnAR  ?.classList.remove('hidden');

  // Cerrar SIDE en server y limpiar PC secundaria
  try{ send({ type:'cupid-off' }); }catch{}
  cleanupRightPeer();
}

btnCupid    ?.addEventListener('click', startCupid);
btnCupidOff ?.addEventListener('click', stopCupid);
// === Botones “Siguiente” por lado (PC) ===
btnNextLeft?.addEventListener('click', ()=>{
  if (!IS_ADMIN) return;
  // Cambia SOLO la izquierda (principal)
  try{ send({ type:'next-main' }); }catch{}
});

btnNextRight?.addEventListener('click', ()=>{
  if (!IS_ADMIN) return;
  // Cambia SOLO la derecha (side); si no hay side viva, el server buscará
  try{ send({ type:'next-side' }); }catch{}
});


// ===== Cupido (MÓVIL) =====
let cupidOnMobile = false;
let pcR_M = null;                 // PeerConnection SIDE (móvil)
let remoteStreamRefR_M = null;

const cupidMini     = qs('#cupidMini');
const remoteVideoR_M= qs('#remoteVideoR_M');
const idleNoiseM_R  = qs('#idleNoiseM_R');
const overlayM_R    = qs('#overlayM_R');

      // ===== GAZE (mirada) =====
let gazeDC = null;               // DataChannel para (u,v)
let sendingGaze = false;         // estado de envío local
let recvRenderEnabled = false;   // si el admin quiere ver la burbuja

let sendGazeTimer = null;
let gazeReady = false;
// === Auto-calibración pasiva (afinidad 2x3) ===
const faceDetector = ('FaceDetector' in window) ? new FaceDetector({ fastMode:true }) : null;

// Afinidad A = [a,b,c, d,e,f] tal que [x y]^T = A * [u v 1]^T
let A = [1,0,0, 0,1,0];      // identidad
const autoCalBuf = [];       // buffer de muestras {ur,vr -> xr,yr} en [0..1]

// Aplica afinidad a (u,v)
function applyAffine(u, v){
  const [a,b,c,d,e,f] = A;
  return [a*u + b*v + c, d*u + e*v + f];
}

// Mínimos cuadrados para ajustar A con >= 4 muestras
function fitAffine(samples){
  if (samples.length < 4) return;

  // XtX (3x3) y XtY (3x2)
  let xx = [0,0,0, 0,0,0, 0,0,0], xy = [0,0, 0,0, 0,0];
  for (const s of samples){
    const u=s.ur, v=s.vr, w=1, x=s.xr, y=s.yr;
    xx[0]+=u*u; xx[1]+=u*v; xx[2]+=u*w;
    xx[3]+=v*u; xx[4]+=v*v; xx[5]+=v*w;
    xx[6]+=w*u; xx[7]+=w*v; xx[8]+=w*w;

    xy[0]+=u*x; xy[1]+=u*y;
    xy[2]+=v*x; xy[3]+=v*y;
    xy[4]+=w*x; xy[5]+=w*y;
  }
  const inv = inv3(xx); if(!inv) return;

  // M = (XtX)^-1 * XtY  => M = [[a d],[b e],[c f]]
  const a = inv[0]*xy[0] + inv[1]*xy[2] + inv[2]*xy[4];
  const d = inv[0]*xy[1] + inv[1]*xy[3] + inv[2]*xy[5];
  const b = inv[3]*xy[0] + inv[4]*xy[2] + inv[5]*xy[4];
  const e = inv[3]*xy[1] + inv[4]*xy[3] + inv[5]*xy[5];
  const c = inv[6]*xy[0] + inv[7]*xy[2] + inv[8]*xy[4];
  const f = inv[6]*xy[1] + inv[7]*xy[3] + inv[8]*xy[5];

  // Mezcla suave para evitar saltos bruscos
  const alpha = 0.3;
  A = [
    alpha*a + (1-alpha)*A[0],
    alpha*b + (1-alpha)*A[1],
    alpha*c + (1-alpha)*A[2],
    alpha*d + (1-alpha)*A[3],
    alpha*e + (1-alpha)*A[4],
    alpha*f + (1-alpha)*A[5],
  ];
}

// inversa 3x3 (array 9)
function inv3(m){
  const [a,b,c, d,e,f, g,h,i] = m;
  const A =  (e*i - f*h), B = -(d*i - f*g), C =  (d*h - e*g);
  const det = a*A + b*B + c*C;
  if (Math.abs(det) < 1e-6) return null;
  const D = -(b*i - c*h), E =  (a*i - c*g), F = -(a*h - b*g);
  const G =  (b*f - c*e), H = -(a*f - c*d), I =  (a*e - b*d);
  const invDet = 1/det;
  return [A*invDet, D*invDet, G*invDet,
          B*invDet, E*invDet, H*invDet,
          C*invDet, F*invDet, I*invDet];
}


function clamp01(t){ return Math.max(0, Math.min(1, t)); }

async function ensureGazeEngine(){
  if (gazeReady) return;
  try{
    webgazer.setRegression('ridge')
            .setTracker('clmtrackr')
            .showVideoPreview(false)
            .showPredictionPoints(false)
            .begin();
    await new Promise(r=>setTimeout(r, 1000)); // warmup
    gazeReady = true;
  }catch(e){ console.warn('WebGazer init error', e); }
}

async function getGazePrediction(){
  try{ return await webgazer.getCurrentPrediction(); }catch{ return null; }
}

// Determina el <video> REMOTO que YO estoy mirando (depende del layout)
function currentRemoteElement(){
  return (layoutMode === 'split') ? document.getElementById('remoteVideo')
                                  : document.getElementById('remoteVideoM');
}

/// ===== Física de burbuja =====
const bubblePhys = {
  // estado normalizado [0..1]
  x: .5, y: .5,      // posición actual
  tx: .5, ty: .5,    // target (u,v)
  vx: 0,  vy: 0,     // velocidad
  // parámetros de spring (ajusta a gusto)
  k: 28,             // rigidez del resorte
  c: 6,              // amortiguación lineal
  // visual
  scaleX: 1, scaleY: 1, rot: 0,
  // housekeeping
  lastT: 0, raf: 0,
};

/**
 * Llama esto para actualizar el target (u,v)
 * y arrancar el loop si está detenido.
 */
function renderGazeOnMyLocalVideo(u, v){
  if (!recvRenderEnabled) return;

  const isSplit = (layoutMode === 'split');
  const layer  = document.getElementById(isSplit ? 'gazeLayerLocalD' : 'gazeLayerLocalM');
  const bubble = document.getElementById(isSplit ? 'gazeBubbleLocalD' : 'gazeBubbleLocalM');
  if (!layer || !bubble) return;

  const vLocal = document.getElementById(isSplit ? 'localVideo' : 'localVideoM');
  const mirrored = vLocal?.classList?.contains('mirror');
  const uu = mirrored ? (1 - u) : u;

  // muestra la burbuja si estaba oculta
  bubble.classList.add('show');

  // setea target y enciende el loop
  bubblePhys.tx = uu;
  bubblePhys.ty = v;
  if (!bubblePhys.raf) {
    bubblePhys.lastT = performance.now();
    bubblePhys.raf = requestAnimationFrame(t => bubbleAnimLoop(t, bubble));
  }
}

/* loop de física + dibujo */
function bubbleAnimLoop(t, bubble){
  const dt = Math.min(0.035, Math.max(0.001, (t - bubblePhys.lastT) / 1000)); // clamp delta
  bubblePhys.lastT = t;

  // resorte 2D hacia (tx,ty)
  const ax = bubblePhys.k * (bubblePhys.tx - bubblePhys.x) - bubblePhys.c * bubblePhys.vx;
  const ay = bubblePhys.k * (bubblePhys.ty - bubblePhys.y) - bubblePhys.c * bubblePhys.vy;
  bubblePhys.vx += ax * dt;
  bubblePhys.vy += ay * dt;
  bubblePhys.x  += bubblePhys.vx * dt;
  bubblePhys.y  += bubblePhys.vy * dt;

  // velocidad para efectos visuales
  const speed = Math.hypot(bubblePhys.vx, bubblePhys.vy);           // ~0..?
  const dir   = Math.atan2(bubblePhys.vy, bubblePhys.vx);           // rad

  // squash & stretch: a más velocidad, más “aplastada”
  // 1) base ~1, 2) límite para no deformar demasiado
  const sAmt = Math.min(0.28, speed * 0.45);    // 0..~0.28
  bubblePhys.scaleX = 1 + sAmt;
  bubblePhys.scaleY = 1 - sAmt * 0.7;

  // ligera rotación hacia la dirección del movimiento
  bubblePhys.rot = dir * 0.25; // reduce para que sea sutil

  // pequeño pulso orgánico (respira) para que no se vea robótica
  const wobble = 0.03 * Math.sin(t * 0.008); // 125 Hz → lento
  const scaleX = bubblePhys.scaleX + wobble;
  const scaleY = bubblePhys.scaleY - wobble * 0.6;

  // tamaño dinámico muy sutil con la velocidad (opcional)
  const base = 30; // px (coincide con CSS)
  const extra = Math.min(6, speed * 12); // hasta +6px
  bubble.style.width  = (base + extra) + 'px';
  bubble.style.height = (base + extra) + 'px';

  // dibuja (usa % para anclar al video local)
  bubble.style.left = (bubblePhys.x * 100) + '%';
  bubble.style.top  = (bubblePhys.y * 100) + '%';
  bubble.style.transform =
    `translate(-50%,-50%) rotate(${bubblePhys.rot}rad) scale(${scaleX}, ${scaleY})`;

  // sombra “direccional” muy suave según velocidad
  const sx = Math.max(-8, Math.min(8, bubblePhys.vx * 24));
  const sy = Math.max(-8, Math.min(8, bubblePhys.vy * 24));
  bubble.style.boxShadow =
    `${sx}px ${sy}px 16px rgba(0,0,0,.16),
     inset 0 0 0 1.5px rgba(255,255,255,.9),
     inset 0 0 18px rgba(255,255,255,.18)`;

  // seguir animando mientras el admin quiera ver la burbuja
  if (recvRenderEnabled) {
    bubblePhys.raf = requestAnimationFrame(tt => bubbleAnimLoop(tt, bubble));
  } else {
    bubblePhys.raf = 0;
  }
}


function clearLocalGazeBubble(){
  document.getElementById('gazeBubbleLocalD')?.classList.remove('show');
  document.getElementById('gazeBubbleLocalM')?.classList.remove('show');
}

    const stage=qs('#stage'), stageMobile=qs('#stageMobile');
    const btnBuscarM=qs('#btn-buscar-m'), btnSalirM=qs('#btn-salir-m');

    const gearBtn = qs('#btn-gear'), gearSheet = qs('#gear-sheet'), swMute = qs('#sw-mute');

    /* ===== NUEVO: refs a idles de video ===== */
    const idleNoiseD = qs('#idleNoiseD');
    const idleNoiseM = qs('#idleNoiseM');
    const idleLocal  = qs('#idle-local');

    /* ===== Mano fantasma (idle móvil) ===== */
    const swipeGhost = document.getElementById('swipe-ghost');
    function setGhostVisible(show){
      if(!swipeGhost) return;
      swipeGhost.classList.toggle('show', !!show);
    }
    function isPageChatVisible(){
      return pages?.chat?.classList.contains('visible');
    }
    function updateGhostHandVisibility(){
      // Mostrar SOLO si: móvil + en sala + idle (!isQueuing && !inCall) + idle remoto visible
      const idleRemoteVisible = !!idleNoiseM && !idleNoiseM.classList.contains('hide');
      const mustShow = isMobile() && isPageChatVisible() && !isQueuing && !inCall && idleRemoteVisible;
      setGhostVisible(mustShow);
    }
 // === Invitado ===
const btnGuest = qs('#btn-guest');
let isGuest = false;

function proceedToChatAfterLoginLikeFlow(displayName='Invitado'){
  // Crea un “usuario” local (sin Firebase)
  currentUser = { displayName };
  isGuest = true;
  localStorage.setItem('ttv_guest', '1');
  youBadge.classList.remove('hidden');

  const n = inpNombre.value || localStorage.getItem('ttv_name') || displayName || '—';
  const a = inpEdad.value    || localStorage.getItem('ttv_age')  || '—';
  youBadge.textContent = `Tú: ${n} (${a}) · ${chosenGender||'—'}`;

  show('chat');
  initLayoutForDevice();

  // Restaurar zoom local guardado (PC)
  zoomState.local = getSavedLocalZoom();
  applyZoom('local');

  // Activar efectos de sala en móvil
  mobilePanEnabled = true;
  startIdlePanIfMobile();

  // Encender cam/mic
  ensureMedia(true).catch(()=>{});
  setIdleUI();
  updateGhostHandVisibility();
}

    /* ===== Estado WebRTC/WS ===== */
    let ws=null, wsOpen=false, myId=null, roomId=null, role=null;
    let pc=null, localStream=null, remoteStreamRef=null;
    let isQueuing=false, inCall=false, autoCycle=false, userHardStop=false;
    let layoutMode='split'; // 'split' | 'mobile-fixed'
    let micMuted=false, camOff=false;
    let currentFacing = 'user'; // móvil
    const iceServers = [
  { urls: 'stun:stun.l.google.com:19302' },
  {
    urls: [
      'turn:45.76.60.11:3478?transport=udp',
      'turn:45.76.60.11:3478?transport=tcp'
      // 'turns:45.76.60.11:5349?transport=tcp' // actívalo cuando tengas TLS/Let's Encrypt
    ],
    username: 'tortilla',
    credential: 'Cl4uD1@2025'
  }
];

    /* ===== ZOOM STATE (PC) ===== */
    const zoomState = { local: 1, remote: 1 };
    const ZOOM_MAX = 4;
    const ZOOM_STEP = 0.15;
    const ZOOM_MIN_LOCAL  = 1;
    const ZOOM_MIN_REMOTE = 0.35;
      
    qs('#zoomInLocal') ?.addEventListener('click', ()=>{
  changeZoom('local', +ZOOM_STEP);
  saveLocalZoom(zoomState.local);
});
qs('#zoomOutLocal')?.addEventListener('click', ()=>{
  changeZoom('local', -ZOOM_STEP);
  saveLocalZoom(zoomState.local);
});
qs('#resetLocal')  ?.addEventListener('click', ()=>{
  zoomState.local = 1;
  applyZoom('local');
  saveLocalZoom(1);
});
const CAM_ZOOM_KEY = 'ttv_local_zoom';

function getSavedLocalZoom(){
  const z = parseFloat(localStorage.getItem(CAM_ZOOM_KEY));
  return Number.isFinite(z) ? Math.min(ZOOM_MAX, Math.max(ZOOM_MIN_LOCAL, z)) : 1;
}
function saveLocalZoom(z){
  localStorage.setItem(CAM_ZOOM_KEY, String(z));
}
    function applyZoom(which){
      const v = (which==='local') ? localVideo : remoteVideo;
      if(!v) return;
      const z = zoomState[which];
      const mirror = v.classList.contains('mirror');
      v.style.transformOrigin = 'center center';
      v.style.transform = mirror ? `scaleX(-1) scale(${z})` : `scale(${z})`;
    }
    function changeZoom(which, delta){
      const isRemote = (which === 'remote');
      const min = isRemote ? ZOOM_MIN_REMOTE : ZOOM_MIN_LOCAL;
      const next = Math.min(ZOOM_MAX, Math.max(min, (zoomState[which] + delta)));
      zoomState[which] = Number(next.toFixed(2));
      applyZoom(which);
    }
    qs('#zoomInLocal') ?.addEventListener('click', ()=> changeZoom('local', +ZOOM_STEP));
    qs('#zoomOutLocal')?.addEventListener('click', ()=> changeZoom('local', -ZOOM_STEP));
    qs('#zoomInRemote')?.addEventListener('click', ()=> changeZoom('remote', +ZOOM_STEP));
    qs('#zoomOutRemote')?.addEventListener('click',()=> changeZoom('remote', -ZOOM_STEP));
    qs('#resetLocal')  ?.addEventListener('click', ()=> { zoomState.local=1; applyZoom('local'); });
    qs('#fitRemote')  ?.addEventListener('click', ()=> { zoomState.remote=1; applyZoom('remote'); });
    function resetZoom(){ zoomState.local=1; zoomState.remote=1; applyZoom('local'); applyZoom('remote'); }

    /* ===== gUM helper tolerante ===== */
    async function getStream({ facing = 'user' } = {}){
      const base = isMobile()
        ? { // 📱 MÓVIL: NO forzar width/height/aspectRatio → evita recortes
            video: { facingMode: { ideal: facing } },
            audio: { echoCancellation:true, noiseSuppression:true }
          }
        : { // 🖥️ PC: 1280x720
            video: { width:{ideal:1280}, height:{ideal:720}, frameRate:{ideal:30}, facingMode:{ ideal:facing } },
            audio: { echoCancellation:true, noiseSuppression:true }
          };

      try{
        return await navigator.mediaDevices.getUserMedia(base);
      }catch(e){
        try{
          if (base.video && base.video.facingMode) delete base.video.facingMode; // fallback
          return await navigator.mediaDevices.getUserMedia(base);
        }catch(err){ throw err; }
      }
    }

    async function ensureMedia(autoPlay=true){
      try{
        const stream = await getStream({ facing: currentFacing });
        if(!localStream){
          localStream = stream;
        }else{
          const newV = stream.getVideoTracks()[0];
          const oldV = localStream.getVideoTracks()[0];
          if(oldV) oldV.stop();
          localStream.removeTrack(oldV);
          localStream.addTrack(newV);
          const sender = pc?.getSenders().find(s=>s.track && s.track.kind==='video');
          if(sender) await sender.replaceTrack(newV);
        }
        attachLocal(localStream, autoPlay);
        applyMuteAndCam();
        return localStream;
      }catch(e){
        alert("Permite cámara y micrófono para continuar.\n" + (e?.message||e));
        throw e;
      }
    }

    function attachLocal(stream, autoPlay=true){
      if(layoutMode==='split'){
        localVideo.srcObject = stream; if(autoPlay) safePlay(localVideo);
        localVideoM.srcObject = null;
        applyZoom('local');
      }else{
        localVideoM.srcObject = stream; if(autoPlay) safePlay(localVideoM);
        localVideo.srcObject = null;
      }
      pipVideo.srcObject = stream; if(autoPlay) safePlay(pipVideo);
      showIdleLocal(false);
    }

    function attachRemote(){
      if(!remoteStreamRef) return;
      if(layoutMode==='split'){
        remoteVideo.srcObject = remoteStreamRef; safePlay(remoteVideo);
        remoteVideoM.srcObject = null;
        applyZoom('remote');
      }else{
        remoteVideoM.srcObject = remoteStreamRef; safePlay(remoteVideoM);
        remoteVideo.srcObject = null;
      }
      // Al entrar video remoto, ocultamos idle (y por tanto se apaga el paneo)
      showIdleRemote(false);
      // Ocultar overlay al mostrar video remoto (por si seguía visible)
      overlayShow(false);
      // 👇 Mano fantasma nunca sobre video remoto
      setGhostVisible(false);
    }

   function makePC(){
  pc = new RTCPeerConnection({iceServers});

  // === GAZE: crea canal si eres "offer"
  if (role === 'offer') {
    const ch = pc.createDataChannel('gaze');
    wireGazeDC(ch);
  }
  pc.ondatachannel = (e)=>{
    if (e.channel.label === 'gaze') wireGazeDC(e.channel);
  };

  pc.onicecandidate = (e)=>{ if(e.candidate) send({type:'ice', candidate:e.candidate}); };
  pc.ontrack = (e)=>{ remoteStreamRef = e.streams[0]; attachRemote(); setupRemoteRatioWatchers(); };
  pc.onconnectionstatechange = ()=> {
    const st = pc.connectionState;
    if(st==='connected'){
      inCall = true; setStatus('Conectado'); overlayShow(false); enableControls();
      // === GAZE: iniciar envío automático sin pedir permiso extra
      startSendingGazeAuto();
    }
    if(st==='disconnected' || st==='failed'){ handleCallEnded('conn:'+st); }
    if(st==='closed'){ setStatus('Cerrado'); }
  };
  return pc;
    }
    function makePCRight(){
  pcR = new RTCPeerConnection({ iceServers });

  pcR.onicecandidate = (e)=>{
    if (e.candidate) send({ type:'ice', candidate:e.candidate, side:true });
  };

  pcR.ontrack = (e)=>{
    remoteStreamRefR = e.streams[0];
    if (remoteVideoR){
      remoteVideoR.srcObject = remoteStreamRefR;
      safePlay(remoteVideoR);
    }
    showRightSearchingUI(false); // llegó video
  };

  pcR.onconnectionstatechange = ()=>{
    const st = pcR.connectionState;
    if (st==='disconnected' || st==='failed' || st==='closed'){
      handleRightEnded('conn:'+st);
    }
  };

  return pcR;
}

function cleanupRightPeer(){
  if (pcR){ try{ pcR.close(); }catch{}; pcR=null; }
  remoteStreamRefR = null;
  if (remoteVideoR) remoteVideoR.srcObject = null;
}

async function startWebRTCRight(role){
  await ensureMedia();
  makePCRight();
  localStream.getTracks().forEach(t=> pcR.addTrack(t, localStream));
  tuneSender();

  if (role==='offer'){
    const offer = await pcR.createOffer();
    await pcR.setLocalDescription(offer);
    send({ type:'offer', sdp: offer, side:true });
  }
}

function handleRightEnded(){
  cleanupRightPeer();
  if (cupidOn){
    showRightSearchingUI(true);
    try{ send({ type:'cupid-find' }); }catch{}
  }else{
    showRightSearchingUI(false);
  }
}
function makePCRightMobile(){
  pcR_M = new RTCPeerConnection({ iceServers });

  pcR_M.onicecandidate = (e)=>{
    if (e.candidate) send({ type:'ice', candidate:e.candidate, side:true });
  };

  pcR_M.ontrack = (e)=>{
    remoteStreamRefR_M = e.streams[0];
    if (remoteVideoR_M){
      remoteVideoR_M.srcObject = remoteStreamRefR_M;
      safePlay(remoteVideoR_M);
    }
    showMiniSideSearching(false);
  };

  pcR_M.onconnectionstatechange = ()=>{
    const st = pcR_M.connectionState;
    if (st==='disconnected' || st==='failed' || st==='closed'){
      handleRightEndedMobile('conn:'+st);
    }
  };

  return pcR_M;
}

function cleanupRightPeerMobile(){
  if (pcR_M){ try{ pcR_M.close(); }catch{}; pcR_M=null; }
  remoteStreamRefR_M = null;
  if (remoteVideoR_M) remoteVideoR_M.srcObject = null;
}

async function startWebRTCRightMobile(role){
  await ensureMedia();
  makePCRightMobile();
  localStream.getTracks().forEach(t=> pcR_M.addTrack(t, localStream));
  tuneSender();

  if (role==='offer'){
    const offer = await pcR_M.createOffer();
    await pcR_M.setLocalDescription(offer);
    send({ type:'offer', sdp: offer, side:true });
  }
}

function handleRightEndedMobile(){
  cleanupRightPeerMobile();
  if (cupidOnMobile){
    showMiniSideSearching(true);
    try{ send({ type:'cupid-find' }); }catch{}
  }else{
    showMiniSideSearching(false);
  }
}
// === Cupido Móvil ===
async function startCupidMobile(){
  if (!IS_ADMIN || cupidOnMobile) return;
  cupidOnMobile = true;

  // Bloquea "Buscar/Siguiente" y muestra la mini en búsqueda
  lockMobileNextInCupid(true);
  showMiniSideSearching(true);

  await connectWS().catch(()=>{});
  try{
    send({ type:'cupid-on' });
    send({ type:'cupid-find' });
  }catch{}
}

function stopCupidMobileAndLeaveAll(){
  if (!cupidOnMobile) return;
  cupidOnMobile = false;

  // Desbloquea botón móvil y oculta mini
  lockMobileNextInCupid(false);
  showMiniSideSearching(false);

  // Corta side y también abandona la sala principal
  try{ send({ type:'cupid-off' }); }catch{}
  cleanupRightPeerMobile();
  stopAll();
}

    function wireGazeDC(ch){
  gazeDC = ch;
  gazeDC.onopen = ()=> console.log('gazeDC open');
  gazeDC.onmessage = (e)=>{
    try{
      const msg = JSON.parse(e.data);
      if (msg.t === 'guv') {
        renderGazeOnMyLocalVideo(msg.u, msg.v);
      }
    }catch{}
  };
}
// Rectángulo del CONTENIDO de video dentro del <video> (compensa object-fit)
function getVideoContentRect(videoEl){
  const elRect = videoEl.getBoundingClientRect();
  const vw = videoEl.videoWidth  || 0;
  const vh = videoEl.videoHeight || 0;
  if (!vw || !vh) return elRect;

  const style = getComputedStyle(videoEl);
  const fit = (style.objectFit || 'fill').trim(); // 'contain' | 'cover' | ...

  const arVideo = vw / vh;
  const arBox   = elRect.width / elRect.height;

  let w = elRect.width, h = elRect.height;
  let x = elRect.left,  y = elRect.top;

  if (fit === 'contain' || fit === 'scale-down') {
    if (arVideo > arBox) {           // bandas arriba/abajo
      h = elRect.width / arVideo;
      y = elRect.top + (elRect.height - h) / 2;
    } else {                         // bandas izq/der
      w = elRect.height * arVideo;
      x = elRect.left + (elRect.width - w) / 2;
    }
  } else if (fit === 'cover') {      // recorte del contenido
    if (arVideo > arBox) {           // recorte izq/der
      w = elRect.height * arVideo;
      x = elRect.left + (elRect.width - w) / 2;
    } else {                         // recorte arriba/abajo
      h = elRect.width / arVideo;
      y = elRect.top + (elRect.height - h) / 2;
    }
  }
  return { left:x, top:y, width:w, height:h };
}
// Calcula (u,v) crudos -> ancla con cara si hay -> corrige con afinidad -> suaviza -> envía
async function computeAndSendGaze(){
  if (!gazeDC || gazeDC.readyState !== 'open') return;

  const vidEl = currentRemoteElement(); if (!vidEl) return;
  const pred = await getGazePrediction(); if (!pred) return;

  // Normaliza respecto al contenido visible del <video> remoto
  const crect = getVideoContentRect(vidEl);
  const ur = clamp01((pred.x - crect.left) / crect.width);
  const vr = clamp01((pred.y - crect.top)  / crect.height);

  // === Auto-anclaje con cara remota (si el navegador lo soporta)
  if (faceDetector){
    try{
      const faces = await faceDetector.detect(vidEl);
      if (faces && faces[0]){
        const bx = faces[0].boundingBox; // en px dentro del <video>
        // Centro de ojos aprox: y al 38% de la caja
        const cx = clamp01((bx.x + bx.width*0.5 - crect.left) / crect.width);
        const cy = clamp01((bx.y + bx.height*0.38 - crect.top)  / crect.height);

        // Si la mirada cruda está cerca de la cara => tomar como par “verdadero”
        const dist = Math.hypot(ur - cx, vr - cy);
        if (dist < 0.18){                      // umbral: 0.12–0.22 según tu UX
          autoCalBuf.push({ ur, vr, xr:cx, yr:cy });
          if (autoCalBuf.length > 60) autoCalBuf.shift();  // ventana deslizante
          if (autoCalBuf.length >= 8) fitAffine(autoCalBuf);
        }
      }
    }catch{} // si falla FaceDetector, seguimos sin ancla
  }

  // Aplica afinidad + clamp
  let [u,v] = applyAffine(ur, vr);
  u = clamp01(u); v = clamp01(v);

  // Suavizado temporal (EMA)
  computeAndSendGaze._lp = computeAndSendGaze._lp || { u, v };
  const k = 0.35;
  u = computeAndSendGaze._lp.u = (1-k)*computeAndSendGaze._lp.u + k*u;
  v = computeAndSendGaze._lp.v = (1-k)*computeAndSendGaze._lp.v + k*v;

  try{
    gazeDC.send(JSON.stringify({ t:'guv', u:+u.toFixed(4), v:+v.toFixed(4) }));
  }catch{}
}


async function startSendingGazeAuto(){
  if (sendingGaze) return;
  sendingGaze = true;
  await ensureGazeEngine();

 // 15 Hz usando la ruta calibrada
sendGazeTimer = setInterval(computeAndSendGaze, 66);

}

function stopSendingGaze(){
  sendingGaze = false;
  if (sendGazeTimer){ clearInterval(sendGazeTimer); sendGazeTimer = null; }
}

    function connectWS(){
      return new Promise((resolve,reject)=>{
        if(ws && wsOpen) return resolve();
        try{ ws = new WebSocket(window.WS_SIGNALLING_URL); }catch(e){ return reject(e); }
      ws.onopen = () => {
  wsOpen = true;

  // 👉 Enviamos identify al servidor si ya hay usuario con email (solo entonces el server podrá marcar isAdmin)
  try {
    const email = auth?.currentUser?.email || null;
    const displayName =
      auth?.currentUser?.displayName || (inpNombre?.value || '—');

    if (email) {
      ws.send(JSON.stringify({
        type: 'identify',
        email,
        displayName
      }));
    }
  } catch {}

  resolve();
};
        ws.onerror = (e)=>{ console.error("WS error", e); reject(e); };
        ws.onclose = ()=>{ wsOpen=false; };
        ws.onmessage = async (msg)=>{
          const data = JSON.parse(msg.data);
          if(data.type==='welcome'){ myId=data.id; }
          if(data.type==='matched'){
            roomId=data.roomId; role=data.role;
            setStatus('Pareja encontrada · Conectando…');
            overlayShow(true);
            if(data.peer && data.peer.name){ peerLabel.classList.remove('hidden'); peerLabel.textContent = 'Pareja: '+(data.peer.name||'—'); }
            try{ await startWebRTC(role); }catch(e){ setStatus('Error WebRTC: '+e.message); overlayShow(false); }
          }
          if(data.type==='offer'){
            await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
            const answer = await pc.createAnswer(); await pc.setLocalDescription(answer);
            send({type:'answer', sdp:answer});
          }
          if(data.type==='answer'){ await pc.setRemoteDescription(new RTCSessionDescription(data.sdp)); }
          if(data.type==='ice'){ try{ await pc.addIceCandidate(data.candidate); }catch(e){} }
          if(data.type==='peer-left'){ handleCallEnded('peer-left'); }
            
          if (data.type === 'role') {
  IS_ADMIN = !!data.isAdmin;
  applyAdminBadgeUI();
}
          if(data.type==='fake-skip'){
  // data.on:boolean, data.role:'admin-view'|'remote-view'
  applyFakeSkip(data.role, !!data.on);
} // === Emparejado SIDE (PC o Móvil) ===
if (data.type === 'matched-side') {
  // pending:true -> sigue buscando; deja el overlay de búsqueda
  if (!data.roomId) {
    if (isMobile() && cupidOnMobile) showMiniSideSearching(true);
    if (!isMobile() && cupidOn)      showRightSearchingUI(true);
  } else {
    // Arranca la segunda PeerConnection según dispositivo
    try{
      if (isMobile() && cupidOnMobile) {
        setStatus('Cupido: conectando mini…');
        showMiniSideSearching(true);
        await startWebRTCRightMobile(data.role);
      } else if (!isMobile() && cupidOn) {
        setStatus('Cupido: conectando derecha…');
        showRightSearchingUI(true);
        await startWebRTCRight(data.role);
      }
    }catch(e){
      setStatus('Error WebRTC SIDE: ' + (e?.message||e));
      if (isMobile()) showMiniSideSearching(false); else showRightSearchingUI(false);
    }
  }
}

// === Señales para la SIDE (PC) ===
if (!isMobile() && cupidOn && pcR) {
  if (data.type === 'answer' && data.sdp) {
    await pcR.setRemoteDescription(new RTCSessionDescription(data.sdp));
  }
  if (data.type === 'offer' && data.sdp) { // por si algún caso side=answer
    await pcR.setRemoteDescription(new RTCSessionDescription(data.sdp));
    const ans = await pcR.createAnswer();
    await pcR.setLocalDescription(ans);
    send({ type:'answer', sdp: ans, side:true });
  }
  if (data.type === 'ice' && data.candidate) {
    try{ await pcR.addIceCandidate(data.candidate); }catch{}
  }
}

// === Señales para la SIDE (MÓVIL) ===
if (isMobile() && cupidOnMobile && pcR_M) {
  if (data.type === 'answer' && data.sdp) {
    await pcR_M.setRemoteDescription(new RTCSessionDescription(data.sdp));
  }
  if (data.type === 'offer' && data.sdp) {
    await pcR_M.setRemoteDescription(new RTCSessionDescription(data.sdp));
    const ans = await pcR_M.createAnswer();
    await pcR_M.setLocalDescription(ans);
    send({ type:'answer', sdp: ans, side:true });
  }
  if (data.type === 'ice' && data.candidate) {
    try{ await pcR_M.addIceCandidate(data.candidate); }catch{}
  }
}

// === Si la SIDE se cae, reintentar automáticamente según modo activo ===
if (data.type === 'peer-left-side') {
  if (!isMobile() && cupidOn) {
    // PC: vuelve a buscar para la derecha
    handleRightEnded('peer-left-side');
  }
  if (isMobile() && cupidOnMobile) {
    // Móvil: vuelve a buscar para la mini
    handleRightEndedMobile('peer-left-side');
  }
}

       
        };
      });
    }

    function send(payload){
      if(wsOpen){ ws.send(JSON.stringify({ ...payload, roomId, from: myId })); }
    }

    async function startWebRTC(role){
      await ensureMedia();
      if (!isMobile()) { await applyARConstraints(); }

      makePC();
      localStream.getTracks().forEach(t=>pc.addTrack(t, localStream));
      tuneSender();

      if(role==='offer'){
        const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
        send({type:'offer', sdp:offer});
      }
    }

    // Limpieza
    function cleanupPeer({ keepLocal = true, closeWsToo = false } = {}){
      if(pc){ try{pc.close()}catch{}; pc=null; }
      if(!keepLocal && localStream){
        localStream.getTracks().forEach(t=>t.stop());
        localStream=null;
        localVideo.srcObject=null; localVideoM.srcObject=null; pipVideo.srcObject=null;
      }
      remoteVideo.srcObject=null; remoteVideoM.srcObject=null; remoteStreamRef=null;
      roomId=null; role=null; inCall=false;
      if(closeWsToo && ws){ try{ ws.close(); }catch{} ws=null; wsOpen=false; }
      peerLabel.classList.add('hidden'); peerLabel.textContent='Pareja: —';
      document.body.classList.remove('remote-portrait');
      zoomState.remote = 1;
      clearFakeSkipUI();
      gazeDC = null;
applyZoom('remote');
    }

    /* ===== Control de botones según estado ===== */
    function enableControls(){
      btnStart && (btnStart.disabled = true);
      btnNext  && (btnNext.disabled  = false);
      btnStop  && (btnStop.disabled  = false);
      btnMute  && (btnMute.disabled  = false);
      btnCam   && (btnCam.disabled   = false);
      if(btnBuscarM) btnBuscarM.textContent = inCall ? 'Siguiente' : (isQueuing ? 'Buscando maricones…' : 'Buscar sala');
    }
    function setSearchingUI(){
      btnStart && (btnStart.disabled = true);
      btnNext  && (btnNext.disabled  = true);
      btnStop  && (btnStop.disabled  = false);
      btnMute  && (btnMute.disabled  = !localStream);
      btnCam   && (btnCam.disabled   = !localStream);
      if(btnBuscarM) btnBuscarM.textContent = 'Buscando maricones…';
    }
    function setIdleUI(){
      btnStart && (btnStart.disabled = false);
      btnNext  && (btnNext.disabled  = true);
      btnStop  && (btnStop.disabled  = true);
      btnMute  && (btnMute.disabled  = !localStream);
      btnCam   && (btnCam.disabled   = !localStream);
      if(btnBuscarM) btnBuscarM.textContent = 'Buscar sala';
    }

    // Auto-cycle
    function handleCallEnded(){
      clearFakeSkipUI();

      cleanupPeer({ keepLocal:true, closeWsToo:false });
      if(autoCycle && !userHardStop){
        setStatus('Buscando siguiente…'); overlayShow(true); setSearchingUI();
        setTimeout(()=>{ findNext(); }, 400);
      }else{
        overlayShow(false); setIdleUI();
      }
      // Volvemos al idle → si estamos en SALA (móvil), reactivar paneo
      showIdleRemote(true);
      // 👇 y evaluar la mano fantasma
      updateGhostHandVisibility();
      stopSendingGaze();
clearLocalGazeBubble();
recvRenderEnabled = false;
    }

    async function joinQueue(){
       if(!currentUser && !isGuest){ alert('Inicia sesión con Google o entra como invitado'); return; }
      if(isQueuing) return;
      isQueuing = true; autoCycle = true; userHardStop = false;
      overlayShow(true);
      setSearchingUI();
      try{
        if(!chosenGender) chosenGender = localStorage.getItem('ttv_gender') || 'Hombre';
        const displayName = (inpNombre.value || localStorage.getItem('ttv_name') || currentUser.displayName || '—');
        const age = (inpEdad.value || localStorage.getItem('ttv_age') || '—');
        await connectWS();

        await ensureMedia();
        if (!isMobile()) { await applyARConstraints(); }

        send({type:'find', gender: chosenGender, displayName, age});
        setStatus('En cola…');
      }catch{
        setStatus('Error de conexión WS'); overlayShow(false); isQueuing=false; autoCycle=false; setIdleUI();
      }
    }

    function findNext(){
      const displayName = (inpNombre.value || localStorage.getItem('ttv_name') || currentUser?.displayName || '—');
      const age = (inpEdad.value || localStorage.getItem('ttv_age') || '—');
      const gender = chosenGender || localStorage.getItem('ttv_gender') || 'Hombre';
      if(!wsOpen){ connectWS().then(()=>send({type:'find', gender, displayName, age})); }
      else { send({type:'find', gender, displayName, age}); }
    }

    async function nextMatch(){
      userHardStop = false; autoCycle = true;
      try{
        send({type:'leave'});
        cleanupPeer({ keepLocal:true, closeWsToo:false });
        setStatus('Buscando siguiente…'); overlayShow(true); setSearchingUI();
        await ensureMedia();
        if (!isMobile()) { await applyARConstraints(); }

        findNext();
      }catch{ setStatus('Error WS (siguiente)'); }
    }

    function stopAll(){
      userHardStop = true; autoCycle = false; isQueuing = false;
      try{ send({type:'leave'}); }catch{}
      cleanupPeer({ keepLocal:true, closeWsToo:false });
      overlayShow(false);
      setStatus('Detenido'); setIdleUI();
      updateGhostHandVisibility();
      clearFakeSkipUI();
          stopSendingGaze();
clearLocalGazeBubble();
recvRenderEnabled = false;
// Si había un side activo, límpialo también
if (cupidOn) {
  cleanupRightPeer();
  showRightSearchingUI(false);
  cupidOn = false;
}
if (cupidOnMobile) {
  cleanupRightPeerMobile();
  showMiniSideSearching(false);
  lockMobileNextInCupid(false);
  cupidOnMobile = false;
}

    }

    /* ===== Layout ===== */
    function setLayout(mode){
      layoutMode = mode;
      if(mode==='split'){
        stage.style.display = '';
        stage.classList.add('layout-split');
        stageMobile.style.display = 'none';
        document.body.classList.remove('no-scroll');
      
      }else{
        stage.style.display = 'none';
        stageMobile.style.display = '';
        document.body.classList.add('no-scroll');
      }
      if(localStream) attachLocal(localStream);
      attachRemote();
    }
    function isMobile(){ return window.matchMedia('(max-width: 640px)').matches }
    function initLayoutForDevice(){
      if(isMobile()){
        const btnAR=qs('#btn-ar'); if(btnAR) btnAR.style.display='none';
        setLayout('mobile-fixed');
      }else{ setLayout('split'); 
         document.body.classList.remove('ar-1-1','ar-16-9');
    document.body.classList.add('ar-4-3');
    const btnAR = document.getElementById('btn-ar');
    if (btnAR) btnAR.textContent = 'AR: 4:3';
      }
    }

  
    /* ===== Botones (PC) ===== */
    btnStart ?.addEventListener('click', joinQueue);
    btnNext  ?.addEventListener('click', nextMatch);
    btnStop  ?.addEventListener('click', stopAll);
    // Botón 👁 (solo admins): alterna render local de la mirada remota
btnEye?.addEventListener('click', ()=>{
  if (!IS_ADMIN || !inCall) return;
  recvRenderEnabled = !recvRenderEnabled;
  btnEye.textContent = recvRenderEnabled ? '👁‍🗨' : '👁';
  if (!recvRenderEnabled) clearLocalGazeBubble();
});
    // Botones nuevos: mute/cam (PC)
    btnMute?.addEventListener('click', ()=>{
      micMuted = !micMuted; applyMuteAndCam(); btnMute.textContent = micMuted ? 'Unmute' : 'Mute';
    });
    btnCam?.addEventListener('click', ()=>{
      camOff = !camOff; applyMuteAndCam(); btnCam.textContent = camOff ? 'Encender cam' : 'Apagar cam';
    });

    // ===== Botón AR (PC) =====
    const btnAR = qs('#btn-ar');
    function setBodyAR(cls, label){
      document.body.classList.remove('ar-1-1','ar-4-3','ar-16-9');
      document.body.classList.add(cls);
      if(btnAR) btnAR.textContent = 'AR: ' + label;
     
    }
    function currentARValue(){
      if(document.body.classList.contains('ar-4-3'))  return 4/3;
      if(document.body.classList.contains('ar-16-9')) return 16/9;
      return 1/1;
    }
    function nextARLabel(){
      const is11  = document.body.classList.contains('ar-1-1');
      const is43  = document.body.classList.contains('ar-4-3');
      if(is11)   return ['ar-4-3','4:3'];
      if(is43)   return ['ar-16-9','16:9'];
      return ['ar-1-1','1:1'];
    }
    async function applyARConstraints(){
      const track = localStream?.getVideoTracks?.()[0];
      if(!track) return;
      try{
        await track.applyConstraints({
          aspectRatio: currentARValue(),
          width:  { ideal: 1280, max: 1920 },
          height: { ideal: 720,  max: 1080 }
        });
      }catch(e1){
        try{ await track.applyConstraints({ aspectRatio: currentARValue() }); }catch(e2){}
      }
    }
    btnAR?.addEventListener('click', async ()=>{
      const [cls,label] = nextARLabel();
      setBodyAR(cls,label);
      await applyARConstraints();
    });

    // MÓVIL: dos botones fijos (UI general)
    btnBuscarM?.addEventListener('click', ()=>{ if(inCall){ nextMatch(); } else if(isQueuing){ stopAll(); } else { joinQueue(); } });
   // === Botones de SALIR (móvil y PC) ===

btnSalirChat?.addEventListener('click', ()=>{
  // Detén todo y limpia emparejamientos
  stopAll();
  // cierra WS y libera cámara/mic
  cleanupPeer({ keepLocal:false, closeWsToo:true });

  // Si fue sesión de invitado, limpia la marca
  localStorage.removeItem('ttv_guest');
  isGuest = false;
  currentUser = null;

  // Si había login Google, cierra sesión (si no, no hace nada)
  if (auth.currentUser) auth.signOut();

  // Volver a la landing y resetear UI móvil
  show('landing');
  mobilePanEnabled = false;
  stopIdlePan();
  setGhostVisible(false);

  // Muestra idles (para que se vea la portada “normal”)
  showIdleRemote(true);
  showIdleLocal(true);

  // Restablece estados de botones
  setIdleUI();
});
    // MÓVIL: engranaje ajustes (mute)
    gearBtn?.addEventListener('click', ()=>{ gearSheet.classList.toggle('show'); });
    swMute?.addEventListener('change', (e)=>{ micMuted = !!e.target.checked; applyMuteAndCam(); });

    // Doble toque móvil: ver remoto completo (contain)
    let remoteContainM = false, lastTap=0;
    function addDoubleTap(el, cb){
      el.addEventListener('touchend', (e)=>{
        const now = Date.now();
        if(now - lastTap < 300){ cb(e); }
        lastTap = now;
      }, {passive:true});
    }
    addDoubleTap(document.getElementById('pane-remote'), ()=>{
      remoteContainM = !remoteContainM;
      remoteVideoM.classList.toggle('contain', remoteContainM);
    });

    // Doble clic PC en el remoto: alterna contain/cover manualmente
    qs('#remoteTile')?.addEventListener('dblclick', ()=>{
      document.body.classList.toggle('remote-portrait');
      applyZoom('remote');
    });

    function isPortrait(){ return window.matchMedia('(orientation: portrait)').matches; }
    function adaptToOrientation(){
      document.body.classList.toggle('portrait-ui', isPortrait());
    }
    window.addEventListener('orientationchange', ()=>{ if(isMobile()) adaptToOrientation(); });
    window.addEventListener('resize', ()=>{ if(isMobile()) adaptToOrientation(); });

    function tuneSender(){
      const sender = pc?.getSenders?.().find(s=>s.track && s.track.kind==='video');
      const vTrack = localStream?.getVideoTracks?.()[0];
      if(!sender || !vTrack) return;
      try { vTrack.contentHint = 'motion'; } catch {}
      try {
        const p = sender.getParameters();
        p.encodings = p.encodings || [{}];
        p.encodings[0].maxBitrate = isMobile() ? 900_000 : 1_800_000;
        p.degradationPreference = 'maintain-framerate';
        sender.setParameters(p);
      } catch {}
    }

    /* ======== DETECTOR retrato remoto ======== */
    function setupRemoteRatioWatchers(){
      if(!remoteVideo) return;
      const mark = ()=> updateRemoteFitClass();
      remoteVideo.addEventListener('loadedmetadata', mark);
      remoteVideo.addEventListener('resize', mark);
      try{
        const track = remoteStreamRef?.getVideoTracks?.()[0];
        const st = track?.getSettings?.();
        if(st?.width && st?.height){ updateRemoteFitClass(st.width, st.height); }
      }catch{}
    }
    function updateRemoteFitClass(wFromTrack, hFromTrack){
      let w = wFromTrack || remoteVideo.videoWidth  || remoteVideoM.videoWidth  || 0;
      let h = hFromTrack || remoteVideo.videoHeight || remoteVideoM.videoHeight || 0;
      if(!w || !h){ setTimeout(()=>updateRemoteFitClass(), 120); return; }
      const ar = w / h;
      const isPortraitRemote = ar < 0.9;
      if(layoutMode==='split'){
        if(isPortraitRemote){ document.body.classList.add('remote-portrait'); }
        else { document.body.classList.remove('remote-portrait'); }
      }
    }

    // Salida limpia
    window.addEventListener('beforeunload', ()=>{ try{ send({type:'leave'}); }catch{} });

    /* ================== AÑADIDOS JS (OmeTV móvil) ================== */
    const btnSwapCam = qs('#btn-swapcam');
    const swipeTip   = qs('#swipe-tip');

    // ===== Paneo L↔R del idle SOLO en móvil y SOLO en SALA =====
    let mobilePanEnabled = false; // true cuando estamos en page-chat en móvil

    function startIdlePanIfMobile(){
      if (mobilePanEnabled && isMobile() && idleNoiseM) {
        idleNoiseM.classList.add('lr-pan');
      }
    }
    function stopIdlePan(){
      if (idleNoiseM) idleNoiseM.classList.remove('lr-pan');
    }

    // Mostrar/Ocultar idles (controla paneo según estado)
    function showIdleRemote(show){
      if (idleNoiseD) idleNoiseD.classList.toggle('hide', !show);
      if (idleNoiseM) idleNoiseM.classList.toggle('hide', !show);
      if (show){
        if (idleNoiseD){ idleNoiseD.muted = true; safePlay(idleNoiseD); }
        if (idleNoiseM){ idleNoiseM.muted = true; safePlay(idleNoiseM); }
        startIdlePanIfMobile();   // en sala móvil: activar paneo
        updateGhostHandVisibility(); // 👈 evaluar mano cuando el idle se muestra
      }else{
  // NO pausar: deja que siga corriendo para evitar flash al primer frame
  stopIdlePan();
  setGhostVisible(false);
}
 }
      // PC: mostrar/ocultar lado derecho (buscando)
function showRightSearchingUI(show){
  if (!remoteTileR) return;
  remoteTileR.style.display = show ? '' : 'none';
  overlayD_R?.classList.toggle('show', !!show);
  if (idleNoiseD_R){
    idleNoiseD_R.classList.toggle('hide', !show);
    idleNoiseD_R.muted = true; safePlay(idleNoiseD_R);
  }
}
// === Posicionar PiP debajo de la topbar, centrado entre las dos pantallas (PC) ===
function positionPipBelowTopbar(){
  if (isMobile()) return;
  const pipEl   = document.getElementById('pip');
  const stageEl = document.getElementById('stage');
  if (!pipEl || pipEl.style.display === 'none') return;

  const topbar   = document.querySelector('.topbar');
  const tbBottom = topbar ? (topbar.getBoundingClientRect().bottom + window.scrollY) : 0;

  // offset base + extra proporcional al alto del área de videos
  const rect  = stageEl?.getBoundingClientRect?.() || { height: 0 };
  const base  = 16;                 // px mínimos
  const extra = Math.min(64, rect.height * 0.06); // máx 64px, ~6% del alto
  const offset = Math.round(base + extra);        // total

  pipEl.style.top = (tbBottom + offset) + 'px';
  pipEl.style.left = '50%';
  pipEl.style.transform = 'translate(-50%, 0)';
}

// Móvil: mini side
function showMiniSideSearching(show){
  if (!cupidMini) return;
  cupidMini.style.display = show ? '' : 'none';
  overlayM_R?.classList.toggle('show', !!show);
  if (idleNoiseM_R){
    idleNoiseM_R.classList.toggle('hide', !show);
    idleNoiseM_R.muted = true; safePlay(idleNoiseM_R);
  }
}

// Móvil: bloquear el botón Buscar/Siguiente mientras Cupido ON
function lockMobileNextInCupid(lock){
  if (!btnBuscarM) return;
  if (lock){
    btnBuscarM.style.display = 'none';
  }else{
    btnBuscarM.style.display = '';
    btnBuscarM.disabled = false;
    btnBuscarM.textContent = 'Buscar sala';
  }
}
function showIdleLocal(show){ if(idleLocal) idleLocal.classList.toggle('hide', !show); }

    // estado inicial (landing): idle visible pero SIN paneo (mobilePanEnabled=false)
    showIdleRemote(true); 
    showIdleLocal(true);
    if (idleNoiseD) safePlay(idleNoiseD);
    if (idleNoiseM) safePlay(idleNoiseM);

    // Cambiar cámara (móvil)
    async function toggleCameraFacing(){
      try{
        const target = (currentFacing === 'user') ? 'environment' : 'user';
        const stream = await getStream({ facing: target });
        const newTrack = stream.getVideoTracks()[0];
        if(localStream){
          const old = localStream.getVideoTracks()[0]; if(old) old.stop();
          localStream.removeTrack(old); localStream.addTrack(newTrack);
          const sender = pc?.getSenders?.().find(s=>s.track && s.track.kind==='video');
          if(sender) await sender.replaceTrack(newTrack);
        }else{
          localStream = stream;
        }
        currentFacing = target;
        attachLocal(localStream);
        applyMuteAndCam();
      }catch(e){ console.warn('No se pudo cambiar la cámara:', e?.message||e); }
    }
    btnSwapCam?.addEventListener('click', toggleCameraFacing);

    // Gestos swipe remoto
    function initSwipeGestures(){
      const el = document.getElementById('pane-remote');
      if(!el) return;
      let startX=0, dx=0, active=false;
      el.addEventListener('touchstart', (e)=>{ active=true; dx=0; startX=e.touches[0].clientX; }, {passive:true});
      el.addEventListener('touchmove',  (e)=>{ if(!active) return; dx = e.touches[0].clientX - startX; }, {passive:true});
      el.addEventListener('touchend',   ()=>{
        if(!active) return; active=false;
        const TH=80;
        if(dx >  TH){ if(inCall){ nextMatch(); } else if(isQueuing){ stopAll(); } else { joinQueue(); } swipeTip?.remove(); }
        else if(dx < -TH){ stopAll(); swipeTip?.remove(); }
      });
    }
    initSwipeGestures();

    /* ====== Mute/Cam helpers ====== */
    function applyMuteAndCam(){
      const a = localStream?.getAudioTracks?.() || [];
      const v = localStream?.getVideoTracks?.() || [];
      a.forEach(t=> t.enabled = !micMuted);
      v.forEach(t=> t.enabled = !camOff);
      if(swMute) swMute.checked = micMuted;
      if(btnMute) btnMute.textContent = micMuted ? 'Unmute' : 'Mute';
      if(btnCam)  btnCam.textContent  = camOff ? 'Encender cam' : 'Apagar cam';
    }
 /* ====== FAKE SKIP (cliente) ====== */
// Estado local del fake skip
let fakeSkipOn = false;
function applyFakeSkip(role, on){
  fakeSkipOn = !!on;

  if (role === 'admin-view') {
    
    overlayShow(on);          
    showIdleRemote(false);   
  } else { 
   
    showIdleRemote(on);
    overlayShow(on);
  }

  if (!on) overlayShow(false);
}


// Atajo de teclado: Enter → alterna fake skip (solo admins + en llamada)
document.addEventListener('keydown', (e)=>{
  if (e.key === 'Enter' && IS_ADMIN && inCall && wsOpen) {
    e.preventDefault();
   send({ type:'fake-skip-toggle' }); 
  }
});

// Al terminar una llamada, asegurarse de limpiar estado visual
function clearFakeSkipUI(){
  fakeSkipOn = false;
  overlayShow(false);
  showIdleRemote(false);
}

    /* ===== Auth: entrar a sala y autoencender cam/mic ===== */
    let currentUser=null;
    auth.onAuthStateChanged(async (u)=>{
      currentUser=u||null;
      if (u && wsOpen) {
  try {
    send({ type:'identify', email: u.email, displayName: u.displayName || (inpNombre?.value || '—') }); // ✅
  } catch {}
}

      if(!u){
        show('landing'); youBadge.classList.add('hidden'); setIdleUI();
        swipeTip?.classList.remove('show');
        // saliendo de sala → desactivar paneo y mano
        mobilePanEnabled = false;
        stopIdlePan();
        setGhostVisible(false);
        return;
      }
      youBadge.classList.remove('hidden');
      const n = inpNombre.value || localStorage.getItem('ttv_name') || u.displayName || '—';
      const a = inpEdad.value    || localStorage.getItem('ttv_age')  || '—';
      youBadge.textContent=`Tú: ${n} (${a}) · ${chosenGender||'—'}`;
      show('chat');
      initLayoutForDevice();
       zoomState.local = getSavedLocalZoom();
applyZoom('local');
      if (isMobile()) { swipeTip?.classList.add('show'); }

      // Al entrar a SALA: habilitar paneo para móvil
      mobilePanEnabled = true;
      // Si en este momento aún está el idle visible, enciende el paneo
      startIdlePanIfMobile();

      // Autoencender cámara y mic
      try{ await ensureMedia(true); }catch{}
      setIdleUI();
      updateGhostHandVisibility(); // 👈 evaluar mano al entrar a sala
    });
    // ====== ADMIN BADGE (cliente, súper simple) ======
const ADMIN_EMAILS_CLIENT = new Set([
  'fajardomiguelangel50@gmail.com',
  'marquisdesade3141@gmail.com',
  'christophergomez6903@gmail.com',
]);

let IS_ADMIN = false;
const adminBadgeEl = document.getElementById('adminBadge');

function applyAdminBadgeUI() {
  if (!adminBadgeEl) return;
  adminBadgeEl.classList.toggle('admin-on',  !!IS_ADMIN);
  adminBadgeEl.classList.toggle('admin-off', !IS_ADMIN);
  // icono/texto
  const icon = adminBadgeEl.querySelector('.badge-icon');
  const text = adminBadgeEl.querySelector('.badge-text');
  if (IS_ADMIN) {
    icon.textContent = '👑';
    text.textContent = 'Admin';
    adminBadgeEl.style.cursor = 'pointer';
    adminBadgeEl.title = 'Panel de admin';
  } else {
    icon.textContent = '🔒';
    text.textContent = 'Admin';
    adminBadgeEl.style.cursor = 'not-allowed';
    adminBadgeEl.title = 'No disponible';
  }
  
   
  if (btnEye) btnEye.classList.toggle('hidden', !IS_ADMIN);
  // Mostrar/ocultar UI de Cupido y Siguientes por lado para admins
btnCupid    ?.classList.toggle('hidden', !IS_ADMIN);
btnCupidOff ?.classList.toggle('hidden', !IS_ADMIN);
btnNextLeft ?.classList.toggle('hidden', !IS_ADMIN);
btnNextRight?.classList.toggle('hidden', !IS_ADMIN);

}
  

// click del badge
adminBadgeEl?.addEventListener('click', (e) => {
  e.preventDefault();
  // Si no es admin, muestra mensaje
  if (!IS_ADMIN) {
    alert('Disponible pronto');
    return;
  }

  // Si es admin, puedes dirigir a tu panel o acción
  // Por ejemplo:
  // location.href = '/admin';
  console.log('Acceso admin');
});



// Al arrancar (sin login) → gris
applyAdminBadgeUI();

// AÑADE sólo este mini-set a tu flujo de auth (en paralelo al tuyo):
auth.onAuthStateChanged((u) => {
  IS_ADMIN = !!(u?.email && ADMIN_EMAILS_CLIENT.has(String(u.email).toLowerCase()));
  applyAdminBadgeUI();
});

// Si entra como invitado, asegúrate de que quede NO admin
if (typeof proceedToChatAfterLoginLikeFlow === 'function') {
  const __origProceed = proceedToChatAfterLoginLikeFlow;
  window.proceedToChatAfterLoginLikeFlow = function(...args){
    IS_ADMIN = false;
    applyAdminBadgeUI();
    return __origProceed.apply(this, args);
  }
}

    // Login Google (con fallback redirect para Safari)
    const btnGoogleel=qs('#btn-google');
    btnGoogle?.addEventListener('click', async ()=>{
      if(!chosenGender){ alert('Elige tu género primero'); return; }
      try{
        const provider=new firebase.auth.GoogleAuthProvider();
        await auth.signInWithPopup(provider);
        localStorage.setItem('ttv_gender', chosenGender);
      }catch(e){
        try{
          const provider=new firebase.auth.GoogleAuthProvider();
          await auth.signInWithRedirect(provider);
        }catch(e2){ alert('Error Google: '+(e2?.message||e?.message)); }
      }
    });
    
  btnGuest?.addEventListener('click', ()=>{
  if(!chosenGender){ alert('Elige tu género primero'); return; }
  const name = inpNombre.value || localStorage.getItem('ttv_name') || 'Invitado';
  localStorage.setItem('ttv_gender', chosenGender);
  proceedToChatAfterLoginLikeFlow(name);
});
  </script>
</body>
</html>